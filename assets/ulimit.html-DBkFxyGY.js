import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,b as a,a as e,d as s,o as n}from"./app-BptLyOzL.js";const o={},r={class:"MathJax",jax:"SVG",style:{position:"relative"}},d={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.919ex",height:"1.887ex",role:"img",focusable:"false",viewBox:"0 -833.9 1290.1 833.9","aria-hidden":"true"};function c(h,i){return n(),l("div",null,[i[16]||(i[16]=a(`<h3 id="bug-描述" tabindex="-1"><a class="header-anchor" href="#bug-描述"><span>Bug 描述</span></a></h3><p>在使用 <code>Docker Compose（version v2.35.1）</code> 部署 <code>MySQL 5.7</code> 时，发现我16G的内存几乎被耗尽，通过 <code>docker stats</code>命令查看，发现MySQL5.7对应的容器占用了几乎所有的内存。<br> 尝试通过 <code>docker run</code> 来部署结果也一样 (<code>docker version: 28.1.1</code>)</p><p>不死心的我于是通过限制资源，在<code>docker-compose.yml</code>中添加了内存大小限制，内容如下：</p><div class="language-yaml line-numbers-mode" data-highlighter="shiki" data-ext="yaml" data-title="yaml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    deploy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">      resources</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        limits</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">          memory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">2G</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但接下来问题更离谱了，MySQL5.7对应的容器甚至不能正常启动了，一直不断重启，通过 <code>docker compose logs mysql57</code> 查看日志，内容如下：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mysql5_7</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2025-05-20</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 14:56:41+00:00</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [Note] [Entrypoint]: Entrypoint script </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> MySQL Server 5.7.32-1debian10 started.</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mysql5_7</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2025-05-20</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 14:56:43+00:00</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [ERROR] [Entrypoint]: mysqld failed </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">while</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> attempting</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> to</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> check</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> config</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mysql5_7</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  |     </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">command</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> was:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> mysqld</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --verbose</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --help</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看起来似乎是因为配置文件的问题，但实际上并没有那么简单。在不联网搜索的情形下询问过多个大模型均不能给出正确答案，只有 Gemini 2.5 Pro 选中联网搜索时，找到了相关的信息。其实通过普通搜索引擎也能找到答案，不少人都遇到过类似的问题。</p><hr><h3 id="内存异常原因" tabindex="-1"><a class="header-anchor" href="#内存异常原因"><span>内存异常原因</span></a></h3><p>通过GitHub Issue 以及各类技术博客的求索，最终发现解决方法为：调整容器的 <code>ulimit</code> 配置，特别是 <code>nofile</code>（最大打开文件描述符数）限制。</p><p>在 <code>docker-compose.yml</code> 文件中为 MySQL 5.7 服务明确地配置一个合理的 <code>ulimits</code> 值。</p><div class="language-yaml line-numbers-mode" data-highlighter="shiki" data-ext="yaml" data-title="yaml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    # ... 其他配置，如 ports, volumes, environment ...</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    ulimits</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">      nproc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">65535</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  # 建议的进程数限制</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">      nofile</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        soft</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">65536</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> # 建议的nofile软限制</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        hard</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">65536</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> # 建议的nofile硬限制</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    # ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">\`ulimit\` 配置建议</p><ul><li><code>nofile</code>：软限制 (soft) 和硬限制 (hard) 均建议从 <code>65536</code> 开始尝试。社区中的成功案例表明，此范围通常能有效解决问题。根据具体需求和系统能力，此值可在 20000 至 100000+ 之间调整。关键在于提供一个明确且合理的值，避免继承可能存在问题的系统默认值。</li><li><code>nproc</code>：用户最大进程数限制，通常设置为 <code>65535</code> 已能满足绝大多数应用场景。</li></ul></div><p>然后重新部署：<code>docker compose down -v &amp;&amp; docker compose up -d</code> ，果然一切正常了。</p><p>但是问题来了，为什么呢？ulimit 是什么？有什么用呢？</p><hr><h3 id="ulimit与内存" tabindex="-1"><a class="header-anchor" href="#ulimit与内存"><span><code>ulimit</code>与内存</span></a></h3><p><code>ulimit</code> 常用于控制进程可使用的系统资源。对于数据库服务而言，<code>nofile</code> 参数尤为重要，因为它直接影响到数据库能够管理的并发连接数和打开的文件数量。</p>`,18)),e("ul",null,[i[15]||(i[15]=a("<li><p><strong><code>docker compose</code> 与 <code>docker run</code> 在 <code>ulimit</code> 上的默认行为差异</strong>：<br><code>docker run</code> 命令允许通过 <code>--ulimit</code> 参数直接为单个容器设置 <code>nofile</code> 等限制，例如 <code>--ulimit nofile=65536:65536</code>。如果未显式指定，容器通常会继承 Docker 守护进程的 <code>ulimit</code> 设置<br><code>docker compose</code> 则在其 YAML 配置文件中通过 <code>ulimits</code> 块来为服务定义资源限制。若 <code>docker-compose.yml</code> 文件中没有为 MySQL 服务明确定义 <code>ulimits</code>，容器同样会继承 Docker 守护进程的默认值。</p></li>",1)),e("li",null,[e("p",null,[i[2]||(i[2]=e("strong",null,[e("mark",null,[e("code",null,"nofile")]),s(" 值过高的“陷阱”")],-1)),i[3]||(i[3]=s("：")),i[4]||(i[4]=e("br",null,null,-1)),i[5]||(i[5]=s(" GitHub 上著名的 ")),i[6]||(i[6]=e("a",{href:"https://github.com/docker-library/mysql/issues/579",target:"_blank",rel:"noopener noreferrer"},"docker-library/mysql#579",-1)),i[7]||(i[7]=s(" Issue，揭示了问题的核心：在某些操作系统环境（如 Arch Linux）或特定 Docker 版本下，容器可能继承一个")),i[8]||(i[8]=e("strong",null,"异常高",-1)),i[9]||(i[9]=s("的 ")),i[10]||(i[10]=e("code",null,"nofile",-1)),i[11]||(i[11]=s(" 默认值（例如，高达 ")),e("mjx-container",r,[(n(),l("svg",d,i[0]||(i[0]=[a('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path></g></g></g></g></g>',1)]))),i[1]||(i[1]=e("mjx-assistive-mml",{unselectable:"on",display:"inline"},[e("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[e("msup",null,[e("mn",null,"2"),e("mrow",{"data-mjx-texclass":"ORD"},[e("mn",null,"30")])])])],-1))]),i[12]||(i[12]=s("，即 1073741816）。实践表明，MySQL 5.7 在面对如此巨大的 ")),i[13]||(i[13]=e("code",null,"nofile",-1)),i[14]||(i[14]=s(" 上限时，其内部的某些内存管理或资源分配机制可能会出现异常，导致内存使用量急剧上升且无法有效释放。"))])])]),i[17]||(i[17]=a(`<hr><h3 id="containerd" tabindex="-1"><a class="header-anchor" href="#containerd"><span>containerd</span></a></h3><p>也有人提出该问题与 Docker 底层容器运行时 <code>containerd</code> 的版本更新有密切关联。</p><p>自 <code>containerd</code> 1.5.10 版本左右开始，由于其自身或其依赖的 Go 语言运行时（特别是 Go 1.19+）对 <code>RLIMIT_NOFILE</code>（即 <code>nofile</code> 的底层表示）硬限制的处理方式进行了调整，可能导致容器继承一个非常高的 <code>nofile</code> 硬限制，并且软限制也随之被拉高至与硬限制相同的值。这意味着，即使用户并未主动修改系统或 Docker 的 <code>ulimit</code> 配置，仅仅是 Docker Engine 或 <code>containerd</code> 的一次常规升级，就可能使得先前运行正常的 MySQL 5.7 + Docker Compose 配置因 <code>nofile</code> 值过高而突然出现内存异常。</p><p>相关的深入讨论和问题追踪可见于 <a href="https://github.com/containerd/containerd/issues/6707" target="_blank" rel="noopener noreferrer">containerd/containerd#6707</a> 和 <a href="https://github.com/containerd/containerd/issues/8249" target="_blank" rel="noopener noreferrer">containerd/containerd#8249</a>。</p><hr><h3 id="内存泄漏bug" tabindex="-1"><a class="header-anchor" href="#内存泄漏bug"><span>内存泄漏BUG</span></a></h3><p>虽然调整 <code>ulimit nofile</code> 是解决 MySQL 5.7 在 Docker Compose 中内存异常的关键，但在某些情况下，问题可能是多因素叠加的结果，或者即便 <code>ulimit</code> 配置合理后，仍有进一步优化内存使用的空间。</p><p>MySQL 官方的 BUG 追踪系统也记录了一些与 MySQL 5.7 内存使用相关的已知问题，这些 BUG 可能在特定条件下被触发或加剧：</p><ul><li><strong>(<a href="https://bugs.mysql.com/bug.php?id=83047" target="_blank" rel="noopener noreferrer">https://bugs.mysql.com/bug.php?id=83047</a>)</strong> ：此 BUG 报告描述了 InnoDB 存储引擎在特定工作负载下（如大量写入或大事务）可能出现内存逐渐增长，最终导致服务器因内存耗尽而停止服务的情况。报告中提及，通过切换到 <code>jemalloc</code> 内存分配库可以有效缓解此问题，这间接指向了 MySQL 5.7 默认使用的 glibc 内存分配器可能存在的效率问题或与特定场景的不兼容。</li><li><strong>(<a href="https://bugs.mysql.com/bug.php?id=97935" target="_blank" rel="noopener noreferrer">https://bugs.mysql.com/bug.php?id=97935</a>)</strong> ：该 BUG 指出，当客户端频繁连接和断开，并且在会话中执行了对 <code>information_schema</code> 的查询（包括MySQL内部执行的 <code>SHOW GLOBAL STATUS</code> 命令，因其会查询 <code>information_schema.global_status</code>）时，MySQL 5.7.28 及相近版本会出现内存泄漏。内存分配被追踪到 <code>mysql_socket_vio_new</code> 相关调用栈。由于 <code>information_schema</code> 的实现在 MySQL 8.0 中已被重写，该 BUG 对 5.7 版本被标记为“不会修复 (Won&#39;t fix)”。</li></ul><hr><h3 id="内存分配优化" tabindex="-1"><a class="header-anchor" href="#内存分配优化"><span>内存分配优化</span></a></h3><ol><li>默认内存分配器 (glibc) 的局限性:</li></ol><p>MySQL 5.7 通常依赖操作系统提供的标准 C 库（glibc）中的 ptmalloc 作为其默认内存分配器。然而，在某些高并发、长连接或特定内存分配与释放模式下，glibc ptmalloc 可能会产生<mark>内存碎片</mark>（Memory Fragmentation）。这意味着即使应用逻辑上已经释放了内存，由于碎片的存在，操作系统层面看到的进程常驻内存集合大小 (RSS) 可能依然居高不下，甚至持续增长。</p><ol start="2"><li>Performance Schema 的内存占用</li></ol><p>MySQL Performance Schema 是一个强大的用于监控服务器内部执行细节的工具。但启用 Performance Schema 会消耗额外的内存资源来存储收集到的性能数据、元数据以及内部数据结构。在内存资源受限的 Docker 容器环境中，这部分开销可能变得尤为显著。</p><p><strong>优化建议</strong>：如果对 MySQL 的详细内部性能监控需求不高，或者内存压力较大，可以考虑禁用 Performance Schema。这通常可以通过在 <code>docker-compose.yml</code> 的 <code>command</code> 字段中为 <code>mysqld</code> 添加启动参数 <code>--performance_schema=0</code> 来实现。</p><div class="language-yaml line-numbers-mode" data-highlighter="shiki" data-ext="yaml" data-title="yaml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    command</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      - </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">mysqld</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      - </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">--performance_schema=0</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      # - 其他 mysqld 启动参数可以继续添加在此</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>MySQL 内部配置参数的审视与调优</li></ol><p>合理的 MySQL 内部参数配置对于控制内存占用同样至关重要。以下是一些关键参数：</p><ul><li><code>innodb_buffer_pool_size</code>：这是 InnoDB 存储引擎最重要的内存组件，用于缓存数据和索引。在容器环境中，应根据为容器分配的内存上限来设定此值，一个常见的经验法则是将其设置为容器可用内存的 <strong>50%-70%</strong> 。设置过大可能导致容器 OOM，过小则影响性能。</li><li><code>max_connections</code>：定义了 MySQL 服务器允许的最大并发客户端连接数。每个连接都会消耗服务器的一定内存资源。应根据应用的实际并发量和容器的内存限制来审慎设置此值，避免远超实际需求，默认的 <code>151</code> 可能对某些轻量级应用过高。</li><li><code>query_cache_size</code> 和 <code>query_cache_type</code>：查询缓存在 MySQL 5.7 中已被官方标记为废弃（deprecated），并在 MySQL 8.0 中被彻底移除。在高并发写入场景下，查询缓存很容易成为性能瓶颈，并且其内存管理也可能不够高效。强烈建议在 MySQL 5.7 中将其<strong>彻底禁用</strong> (将 <code>query_cache_size</code> 和 <code>query_cache_type</code> 均设置为 <code>0</code>) 。</li><li>其他参数：如 <code>table_open_cache</code>、<code>table_definition_cache</code>（与打开文件描述符相关）、<code>thread_cache_size</code>、<code>key_buffer_size</code>（若主要使用 InnoDB，可设较小值，如 8M-16M）以及各种会话级缓冲区（如 <code>read_buffer_size</code>, <code>sort_buffer_size</code>, <code>join_buffer_size</code> 等）都应根据实际工作负载和容器资源进行审慎配置，避免不必要的内存浪费。</li></ul><hr><h3 id="内存分配器" tabindex="-1"><a class="header-anchor" href="#内存分配器"><span>内存分配器</span></a></h3><p>高级优化：采用替代内存分配器 (jemalloc / TCMalloc):</p><p>鉴于默认 glibc ptmalloc 可能存在的内存碎片和效率问题，更换为更先进的内存分配器（如 <code>jemalloc</code> 或 Google 的 <code>TCMalloc</code>）是一个有效的进阶优化手段。<code>jemalloc</code> 因其在减少内存碎片和提升高并发环境下内存分配性能方面的优异表现，尤其被广泛推荐用于改善 MySQL 的内存使用效率和稳定性。</p><p><strong>实施方法</strong>：在 Docker 环境中，这通常通过构建一个自定义的 Docker 镜像来实现。以 <code>jemalloc</code> 为例，可以在官方 <code>mysql:5.7</code> 镜像（通常基于 Debian/Ubuntu）的基础上，安装 <code>libjemalloc1</code> 包，然后通过 <code>LD_PRELOAD</code> 环境变量在 MySQL 服务器启动前预加载 <code>jemalloc</code> 的共享库。</p><div class="hint-container important"><p class="hint-container-title">Dockerfile for \`mysql:5.7\` with \`jemalloc\`</p><div class="language-dockerfile line-numbers-mode" data-highlighter="shiki" data-ext="dockerfile" data-title="dockerfile" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># Dockerfile for mysql:5.7 with jemalloc</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> mysql:5.7</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># Install jemalloc (libjemalloc1 for Debian/Ubuntu based images)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># The path /usr/lib/x86_64-linux-gnu/libjemalloc.so.1 is common for jemalloc v1 on Debian.</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># Verify the exact path if issues arise; it might be libjemalloc.so.2 for newer versions of the lib.</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">RUN</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> apt-get update &amp;&amp; \\</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    apt-get install -y libjemalloc1 &amp;&amp; \\</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    rm -rf /var/lib/apt/lists/*</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># Set LD_PRELOAD to use jemalloc for all processes started by this image&#39;s entrypoint/cmd.</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># Ensure the path to libjemalloc.so.1 is correct for the base image.</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ENV</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so.1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><p>构建此自定义镜像后（例如，<code>docker build -t my-mysql57-jemalloc .</code>），在 <code>docker-compose.yml</code> 文件中将 <code>image</code> 指令指向这个新构建的镜像名即可。</p><hr><h3 id="升级-mysql-版本" tabindex="-1"><a class="header-anchor" href="#升级-mysql-版本"><span>升级 MySQL 版本</span></a></h3><p>如果业务应用的兼容性允许，并且没有特定的历史原因或依赖必须坚守 MySQL 5.7，那么<strong>升级到 MySQL 8.0 或更高版本</strong>通常是解决此类内存问题的最彻底和最具前瞻性的方案。</p><p>目前MySQL 8.0 在相同的 Docker Compose 环境下没有出现类似的内存异常问题。这得益于 MySQL 8.0 在内存管理机制、<code>information_schema</code> 的实现效率、Performance Schema 的默认行为和资源消耗等方面均有显著的改进和重写。例如，前述的 Bug #97935（<code>information_schema</code> 内存泄漏）在 MySQL 8.0 中因该组件的重写而自然解决。</p><hr><h3 id="关键参考信息" tabindex="-1"><a class="header-anchor" href="#关键参考信息"><span>关键参考信息</span></a></h3><p>以下列出与本文讨论内容高度相关的 MySQL 官方 BUG 报告和 GitHub Issue 链接：</p><ul><li><p><strong>MySQL Bugs</strong>:</p><ul><li><a href="https://bugs.mysql.com/bug.php?id=83047" target="_blank" rel="noopener noreferrer">Bug #83047: Memory usage gradually increases and brings server to halt</a> (描述了 InnoDB 内存持续增长问题，并提及 <code>jemalloc</code> 作为缓解方案)</li><li><a href="https://bugs.mysql.com/bug.php?id=97935" target="_blank" rel="noopener noreferrer">Bug #97935: Memory leak in client connection using information_schema</a> (指出了 MySQL 5.7.28 在特定 <code>information_schema</code> 查询下的内存泄漏，该问题在 5.7 版本中不会修复)</li></ul></li><li><p><strong>GitHub Issues (Docker &amp; <code>containerd</code> 相关)</strong>:</p><ul><li><a href="https://github.com/docker-library/mysql/issues/579" target="_blank" rel="noopener noreferrer">docker-library/mysql#579: Really high memory usage</a> (核心讨论区，详细记录了 <code>ulimit nofile</code> 设置过高导致 MySQL 5.7 内存异常的发现过程和解决方案)</li><li><a href="https://github.com/containerd/containerd/issues/6707" target="_blank" rel="noopener noreferrer">containerd/containerd#6707: 1.5.10 causes memory leak in mysql container</a> (指出了 <code>containerd</code> 版本升级（特别是 1.5.10）如何改变了 <code>LimitNOFILE</code> 的默认行为，进而引发了 MySQL 容器的内存问题)</li><li><a href="https://github.com/containerd/containerd/issues/8249" target="_blank" rel="noopener noreferrer">containerd/containerd#8249: RLIMIT_NOFILE soft limit is raised implicitly to hard limit since Go 1.19</a> (深入探讨了 Go 语言版本更新对 <code>containerd</code> 处理 <code>RLIMIT_NOFILE</code> 行为的影响，是理解 <code>nofile</code> 值变化的深层原因)</li><li><a href="https://www.google.com/search?q=https://github.com/containerd/containerd/pull/7566" target="_blank" rel="noopener noreferrer">containerd/containerd#7566: Revert commit that changed LimitNOFILE to infinity to avoid regressions</a> (相关的 Pull Request 和社区关于回退 <code>LimitNOFILE</code> 默认值为 <code>infinity</code> 的讨论)</li><li><a href="https://gist.github.com/vicenterusso/ae6d6c903b790e5dae91c339c1ce2ba8" target="_blank" rel="noopener noreferrer">Gist ae6d6c903b790e5dae91c339c1ce2ba8 by vicenterusso: Docker Compose fix for MySQL memory leak on Fedora</a> (提供了一个具体的 <code>docker-compose.yml</code> 中 <code>ulimits</code> 配置示例，用于解决 Fedora 等系统上的 MySQL 内存泄漏问题)</li><li><a href="https://github.com/cBioPortal/cbioportal/issues/10523" target="_blank" rel="noopener noreferrer">cBioPortal/cbioportal#10523: mySQL memory leak using docker compose on Rocky Linux 9.3</a> (展示了在具体项目中如何通过调整 <code>ulimits</code> 来解决 MySQL 内存泄漏问题)</li><li><a href="https://github.com/lando/lando/issues/3523" target="_blank" rel="noopener noreferrer">lando/lando#3523: Mysql container hogs memory</a> (另一个指向 <code>ulimit</code> 和 <code>containerd</code> 问题的社区案例)</li></ul></li></ul>`,36))])}const m=t(o,[["render",c],["__file","ulimit.html.vue"]]),g=JSON.parse('{"path":"/posts/db/ulimit.html","title":"MySQL5.7在compose部署时内存异常Bug","lang":"en-US","frontmatter":{"article":true,"date":"2025-05-20T00:00:00.000Z","category":["Database","MySQL"],"tag":["Database","MySQL","ulimit"],"shortTitle":"MySQL5.7内存异常","title":"MySQL5.7在compose部署时内存异常Bug","order":30,"description":"Bug 描述 在使用 Docker Compose（version v2.35.1） 部署 MySQL 5.7 时，发现我16G的内存几乎被耗尽，通过 docker stats命令查看，发现MySQL5.7对应的容器占用了几乎所有的内存。 尝试通过 docker run 来部署结果也一样 (docker version: 28.1.1) 不死心的我于是...","head":[["meta",{"property":"og:url","content":"https://x.app/posts/db/ulimit.html"}],["meta",{"property":"og:site_name","content":"doc"}],["meta",{"property":"og:title","content":"MySQL5.7在compose部署时内存异常Bug"}],["meta",{"property":"og:description","content":"Bug 描述 在使用 Docker Compose（version v2.35.1） 部署 MySQL 5.7 时，发现我16G的内存几乎被耗尽，通过 docker stats命令查看，发现MySQL5.7对应的容器占用了几乎所有的内存。 尝试通过 docker run 来部署结果也一样 (docker version: 28.1.1) 不死心的我于是..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-05-22T04:01:46.000Z"}],["meta",{"property":"article:author","content":"ventixy"}],["meta",{"property":"article:tag","content":"Database"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:tag","content":"ulimit"}],["meta",{"property":"article:published_time","content":"2025-05-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-22T04:01:46.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL5.7在compose部署时内存异常Bug\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-05-20T00:00:00.000Z\\",\\"dateModified\\":\\"2025-05-22T04:01:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ventixy\\",\\"url\\":\\"https://www.ventix.top\\"}]}"]]},"headers":[{"level":3,"title":"Bug 描述","slug":"bug-描述","link":"#bug-描述","children":[]},{"level":3,"title":"内存异常原因","slug":"内存异常原因","link":"#内存异常原因","children":[]},{"level":3,"title":"ulimit与内存","slug":"ulimit与内存","link":"#ulimit与内存","children":[]},{"level":3,"title":"containerd","slug":"containerd","link":"#containerd","children":[]},{"level":3,"title":"内存泄漏BUG","slug":"内存泄漏bug","link":"#内存泄漏bug","children":[]},{"level":3,"title":"内存分配优化","slug":"内存分配优化","link":"#内存分配优化","children":[]},{"level":3,"title":"内存分配器","slug":"内存分配器","link":"#内存分配器","children":[]},{"level":3,"title":"升级 MySQL 版本","slug":"升级-mysql-版本","link":"#升级-mysql-版本","children":[]},{"level":3,"title":"关键参考信息","slug":"关键参考信息","link":"#关键参考信息","children":[]}],"git":{"createdTime":1747886506000,"updatedTime":1747886506000,"contributors":[{"name":"drizzle","email":"msdrizzle@outlook.com","commits":1}]},"readingTime":{"minutes":10.53,"words":3159},"filePathRelative":"posts/db/ulimit.md","localizedDate":"May 20, 2025","excerpt":"<h3>Bug 描述</h3>\\n<p>在使用 <code>Docker Compose（version v2.35.1）</code> 部署 <code>MySQL 5.7</code> 时，发现我16G的内存几乎被耗尽，通过 <code>docker stats</code>命令查看，发现MySQL5.7对应的容器占用了几乎所有的内存。<br>\\n尝试通过 <code>docker run</code> 来部署结果也一样 (<code>docker version: 28.1.1</code>)</p>\\n<p>不死心的我于是通过限制资源，在<code>docker-compose.yml</code>中添加了内存大小限制，内容如下：</p>","autoDesc":true}');export{m as comp,g as data};
