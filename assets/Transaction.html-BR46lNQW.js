import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as e,o as n}from"./app-DHX3xOTp.js";const l={};function t(d,i){return n(),a("div",null,i[0]||(i[0]=[e(`<h2 id="mysql-transaction" tabindex="-1"><a class="header-anchor" href="#mysql-transaction"><span>MySQL Transaction</span></a></h2><p><strong>事务（Transaction）</strong>：是由一系列对数据库中数据进⾏访问（查询）与更新（增删改）的操作所组成的⼀个程序执行逻辑单元。这些操作，要么都成功，要么都不成功。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 事务相关命令：</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">begin</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;                </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 开始，还可以使用下列语法：</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">start transaction</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">commit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;               </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 提交：使得当前的修改确认</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">rollback</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;             </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 回滚：使得当前的修改被放弃</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="事务的acid特性" tabindex="-1"><a class="header-anchor" href="#事务的acid特性"><span>事务的ACID特性</span></a></h3><p>事务具有四个重要特征：原子性（Atomicity），一致性（Consistency），隔离性（Isolation），持久性（Durability）。简称<strong>ACID特性</strong></p><div class="hint-container info"><p class="hint-container-title">事务的ACID特性</p><h4 id="原子性-atomicity" tabindex="-1"><a class="header-anchor" href="#原子性-atomicity"><span>原子性（Atomicity）</span></a></h4><p>事务是一个不可分割的最小工作单位，事务中的所有操作要么全部完成，要么全部不执行。事务执⾏过程中如果出错， 会回滚到事务开始前的状态，所有的操作就像没有发⽣一样。</p><ul><li>作用：保证事务的完整性，防止部分操作成功而部分操作失败导致的数据不一致。</li><li>实现方式: 通过<code>Undo Log</code> 支持事务的回滚</li></ul><h4 id="一致性-consistency" tabindex="-1"><a class="header-anchor" href="#一致性-consistency"><span>⼀致性（Consistency）</span></a></h4><p>一个事务在执⾏之前和执行之后，数据库都必须处于⼀致性状态。即事务必须是数据库从一个一致性状态到另外一个一致性状态。<br><em>比如：如果从A账户转账到B账户，不可能因为A账户扣了钱，⽽B账户没有加钱（两个账号的总金额要保持一致状态）</em></p><ul><li>作用：确保数据库从一个一致状态转换到另一个一致状态，即使事务失败也不会破坏数据库的一致性。</li><li>实现方式：日志和约束机制，事务的自动回滚 (或者说由A,I,D共同保证)</li></ul><h4 id="隔离性-isolation" tabindex="-1"><a class="header-anchor" href="#隔离性-isolation"><span>隔离性（Isolation）</span></a></h4><p><mark>事务的执行是独立的，不受其他事务的干扰</mark>。一个事务的中间状态对其他事务是不可见的。</p><p>在并发环境中，并发的事务是互相隔离的。也就是说，不同的事务并发操作相同的数据时，每个事务都有各自完整的数据空间。 ⼀个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务是不能互相干扰的。</p><ul><li>作用：防止多个事务并发执行时产生的相互干扰，确保事务的执行结果是正确的。</li><li>实现方式：不同的隔离级别，MVCC</li></ul><p>在事务中，有隔离级别的定义，不同的隔离级别有不同的影响的程度。</p><h4 id="持久性-durability" tabindex="-1"><a class="header-anchor" href="#持久性-durability"><span>持久性（Durability）</span></a></h4><p>一旦事务提交，其对数据库的改变是永久的，即使系统发生故障也不会丢失。</p><ul><li>作用：确保事务的结果能够持久保存，不会因为系统崩溃或其他问题而丢失。</li><li>实现方式：<strong>Redo Log &amp; <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_doublewrite_buffer" target="_blank" rel="noopener noreferrer">doublewrite buffer</a></strong></li></ul></div><h3 id="事务的并发问题" tabindex="-1"><a class="header-anchor" href="#事务的并发问题"><span>事务的并发问题</span></a></h3><p>在不同的隔离级别下，多个事务并发执行时可能会产生一些问题，如：脏读，不可重复读，幻读</p><div class="hint-container caution"><p class="hint-container-title">事务的并发问题</p><h4 id="脏读-dirty-read" tabindex="-1"><a class="header-anchor" href="#脏读-dirty-read"><span>脏读（Dirty Read）</span></a></h4><ul><li><p><strong>一个事务读取到了另外一个事务还没提交的数据</strong>。例：事务A读取了事务B更新但未提交的数据（脏数据） <em>脏数据</em>：是指事务对缓冲池中行记录的修改，还没有被提交（commit）</p></li><li><p>脏读发生的条件是需要事务的隔离级别为 <code>READ UNCOMMITTED</code></p></li></ul><h4 id="不可重复读-nonrepeatable-read" tabindex="-1"><a class="header-anchor" href="#不可重复读-nonrepeatable-read"><span>不可重复读（Nonrepeatable Read）</span></a></h4><ul><li><p><strong>一个事务在两次读取同一数据时，由于另一个事务在这两次读取之间修改了数据，导致两次读取的结果不同</strong>。</p></li><li><p><em>不可重复读和脏读的区别</em> 是：脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据</p></li></ul><p>有时候，不可重复读的问题是可以接受的，因为其读到的是已经提交的数据，本身并不会带来很大的问题</p><h4 id="幻读-phantom-read" tabindex="-1"><a class="header-anchor" href="#幻读-phantom-read"><span>幻读（Phantom Read）</span></a></h4><p><strong>在一个事务内，读取数据记录条数前后不一致</strong>。详细来说：一个事务在两次查询相同范围的数据时，由于另一个事务在这两次查询之间插入了新的数据，导致第二次查询的结果集包含了第一次查询没有的数据。</p><blockquote><p>例如：</p><ol><li>事务 A ： <code>select * from student where age &gt; 10</code>，假设查到了 10 行数据；</li><li>然后事务 B 往里面加入了一批数据 （或者删除了一些数据）</li><li>事务 A 再查的用条件查询语句查询的时候，发现查到了15条</li></ol></blockquote></div><p><strong>脏写或更新丢失(Lost Update)</strong> ： 当两个或多个事务更新同一行记录，会产生更新丢失现象:</p><ul><li>回滚覆盖：一个事务回滚操作，把其他事务已提交的数据给覆盖了。</li><li>提交覆盖：一个事务提交操作，把其他事务已提交的数据给覆盖了。</li></ul><h3 id="事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#事务的隔离级别"><span>事务的隔离级别</span></a></h3><p>为了处理并发问题，SQL标准定义了四种隔离级别，每种级别提供了不同程度的隔离性：</p><div class="hint-container info"><p class="hint-container-title">事务的隔离级别</p><h4 id="❑-read-uncommitted-读未提交" tabindex="-1"><a class="header-anchor" href="#❑-read-uncommitted-读未提交"><span>❑ Read Uncommitted（读未提交）</span></a></h4><p>最低/最不安全的隔离级别(唯一能读到脏数据的隔离级别) 有脏读、不可重复读、虚幻读的问题</p><h4 id="❑-read-committed-读已提交" tabindex="-1"><a class="header-anchor" href="#❑-read-committed-读已提交"><span>❑ Read Committed（读已提交）</span></a></h4><p>只能读取已经提交的数据、解决了脏读问题，但是仍存在可重复读问题和幻读</p><h4 id="❑-repeatable-read-可重复读" tabindex="-1"><a class="header-anchor" href="#❑-repeatable-read-可重复读"><span>❑ Repeatable Read（可重复读）</span></a></h4><p>标准SQL的定义下仍可能存在幻读问题，但MySQL下没有幻读问题</p><h4 id="❑-serializable-顺序读-可串行化-序列化" tabindex="-1"><a class="header-anchor" href="#❑-serializable-顺序读-可串行化-序列化"><span>❑ Serializable（顺序读 / 可串行化 / 序列化）</span></a></h4><p>最严格的事务隔离级别、事务只能一个接一个地处理，不能并发(有效率问题)</p></div><p>不同事务隔离级别下的不同的问题总结：</p><table><thead><tr><th>事务隔离级别 \\ 并发问题</th><th style="text-align:center;">脏读(Dirty Read)</th><th style="text-align:center;">不可重复读</th><th style="text-align:center;">（虚）幻读</th></tr></thead><tbody><tr><td>read uncommitted（读未提交）</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td>read committed（读已提交）</td><td style="text-align:center;">X</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td>repeatable read（可重复读）</td><td style="text-align:center;">X</td><td style="text-align:center;">X</td><td style="text-align:center;">X(在MySQL下没有)</td></tr><tr><td>serializable（序列化）</td><td style="text-align:center;">X</td><td style="text-align:center;">X</td><td style="text-align:center;">X</td></tr></tbody></table><p>MySQL中InnoDB存储引擎默认支持的隔离级别是 <code>REPEATABLE READ</code>，但是与标准SQL不同的是，InnoDB存储引擎在<code>REPEATABLE READ</code>事务隔离级别下，通过<strong>Next-Key Lock</strong> 有效地防止了幻读问题</p><div class="hint-container tip"><p class="hint-container-title">关于MySQL默认隔离级别的介绍</p><ul><li><p><code>InnoDB</code> offers all four transaction isolation levels described by the SQL:1992 standard:<br><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_read-uncommitted" target="_blank" rel="noopener noreferrer"><code>READ UNCOMMITTED</code></a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_read-committed" target="_blank" rel="noopener noreferrer"><code>READ COMMITTED</code></a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read" target="_blank" rel="noopener noreferrer"><code>REPEATABLE READ</code></a>, and <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_serializable" target="_blank" rel="noopener noreferrer"><code>SERIALIZABLE</code></a>.</p></li><li><p>The default isolation level for <code>InnoDB</code> is <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read" target="_blank" rel="noopener noreferrer"><code>REPEATABLE READ</code></a>.</p></li></ul></div><div class="hint-container important"><p class="hint-container-title">Next-Key Lock锁算法 / MVCC / Gap Locking</p><p><code>Next-Key Lock</code> 锁算法是指结合了行锁和间隙锁（Gap Locking）的一种锁策略，主要用于防止幻读问题。</p><h4 id="多版本并发控制-mvcc" tabindex="-1"><a class="header-anchor" href="#多版本并发控制-mvcc"><span>多版本并发控制（MVCC）</span></a></h4><p>多版本并发控制（MVCC）是一种并发控制机制，允许多个事务在同一时间访问同一数据的不同版本，而不需要阻塞其他事务。具体来说：</p><ul><li><strong>版本链</strong>：每个数据行可以有多个版本，每个版本带有时间戳或事务ID。</li><li><strong>读取不阻塞写入</strong>：事务读取数据时，看到的是事务开始时的数据快照，不会阻塞其他事务的写操作。</li><li><strong>写入不阻塞读取</strong>：事务写入数据时，不会阻塞其他事务的读操作。</li></ul><p><mark>多版本并发控制（MVCC） 是 InnoDB 用来实现 <code>Repeatable Read</code> 隔离级别的一种机制(也即是用来提高并发性能的一种机制)</mark></p><h4 id="间隙锁-gap-locking" tabindex="-1"><a class="header-anchor" href="#间隙锁-gap-locking"><span>间隙锁（Gap Locking）</span></a></h4><p>间隙锁是一种锁定机制，用于锁定数据行之间的间隙，防止其他事务在这些间隙中插入新的数据。具体来说：</p><ul><li><strong>锁定间隙</strong>：不仅锁定实际的数据行，还锁定数据行之间的空隙。</li><li><strong>防止幻读</strong>：通过锁定间隙，防止其他事务在这些间隙中插入新的数据，从而防止幻读问题。</li></ul><h4 id="next-key-lock" tabindex="-1"><a class="header-anchor" href="#next-key-lock"><span>Next-Key Lock</span></a></h4><p><code>Next-Key Lock</code> 是一种结合了行锁和间隙锁的锁策略，主要用于解决幻读问题。具体来说：</p><ul><li><strong>行锁</strong>：锁定实际的数据行。</li><li><strong>间隙锁</strong>：锁定数据行之间的间隙。</li><li><strong>范围锁</strong>：锁定一个范围内的所有数据行和间隙。</li></ul><p><code>Next-Key Lock</code> 锁住的不仅仅是单个数据行，还包括该行前面的间隙。因此，它实际上是一个范围锁，可以防止其他事务在该范围内插入新的数据。</p><p><strong>示例</strong>：假设有一个索引包含以下数据行：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>10, 20, 30, 40</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在一个 <code>Repeatable Read</code> 隔离级别下，如果一个事务执行了以下查询：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 40</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> FOR</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> UPDATE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个查询会使用 <code>Next-Key Lock</code> 锁住以下范围：</p><ul><li>从 10 到 20 的间隙</li><li>数据行 20</li><li>从 20 到 30 的间隙</li><li>数据行 30</li><li>从 30 到 40 的间隙</li></ul><p>这样，其他事务就无法在这些间隙中插入新的数据，从而防止了幻读问题。</p><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h4><ul><li><strong>MVCC</strong>：允许多个事务在同一时间访问同一数据的不同版本，提高并发性能。</li><li><strong>间隙锁</strong>：锁定数据行之间的间隙，防止其他事务在这些间隙中插入新的数据。</li><li><strong>Next-Key Lock</strong>：结合了行锁和间隙锁，锁定一个范围内的所有数据行和间隙，防止幻读问题。</li></ul></div><h2 id="mvcc机制详解" tabindex="-1"><a class="header-anchor" href="#mvcc机制详解"><span>MVCC机制详解</span></a></h2><p>多版本并发控制（Multi-Version Concurrency Control，简称 MVCC，<code>Copy on Write</code>的思想）通过维护数据的不同版本来实现<strong>对同一数据的无锁并发访问</strong>，大大提高了数据库的吞吐量及读写性能。</p><p>MVCC最大的好处是读不加锁，读写不冲突。在读多写少的系统应用中，读写不冲突是非常重要的，极大的提升系统的并发性能，这也是为什么现阶段几乎所有的关系型数据库都支持 MVCC 的原因，MVCC是 <code>Read Commited</code> 和 <code>Repeatable Read</code> 两种隔离级的实现基础。</p><div class="hint-container important"><p class="hint-container-title">MVCC核心基础</p><ul><li>数据行的隐藏字段：包含用于<code>指向历史版本的指针</code>，每行数据可凭此找到它的历史版本</li><li>undo log：存储数据行的多个版本信息</li><li>read view：提供了数据版本确定的依据，用于确定应该获取哪个版本的数据</li></ul></div><p>MySQL官网关于MVCC的介绍参照：<a href="https://dev.mysql.com/doc/refman/8.4/en/innodb-multi-versioning.html" target="_blank" rel="noopener noreferrer">innodb-multi-versioning</a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html" target="_blank" rel="noopener noreferrer">Consistent Nonlocking Reads</a></p><h3 id="数据行隐藏字段" tabindex="-1"><a class="header-anchor" href="#数据行隐藏字段"><span>数据行隐藏字段</span></a></h3><p>InnoDB 存储引擎在每个数据行中添加了几个隐藏字段，用于支持 MVCC：</p><ul><li><p><strong>DB_TRX_ID</strong>：记录最近一次对本记录进行插入或修改的事务ID。（占六个字节）<br> 删除操作也会被视为一个update操作，只是有额外的删除标记（Delete Bit）</p></li><li><p><strong>DB_ROLL_PTR</strong>：指向该行的回滚段（undo log）的指针，用于找到该行的旧版本。(占用七个字节)</p></li><li><p><strong>DB_ROW_ID</strong>：随着新行插入而单调递增的行ID，数据行没有主键时，为行提供一个唯一的标识<br> DB_ROW_ID占用六个字节, 若无聚簇索引则作为聚簇索引使用。</p></li></ul><figure><img src="https://image.ventix.top/img02/20220119212913677.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="undolog与版本链" tabindex="-1"><a class="header-anchor" href="#undolog与版本链"><span>UndoLog与版本链</span></a></h3><p>事务在对数据操作前，undolog会记录<mark>可以通过事务回滚到上一个版本数据</mark>的信息</p><ul><li><code>insert undo log</code>: 事务insert新记录时产生的undolog, 只在事务回滚时需要，并且在事务提交后就可以立即丢弃</li><li><code>update undo log</code>: 事务进行delete和update操作时产生的undo log<br> 不仅事务回滚需要，快照读也需要，只有当数据库所使用的快照中不涉及 对应的undo log才会被<code>purge</code>线程删除</li></ul><div class="hint-container warning"><p class="hint-container-title">版本链</p><p>每次更新操作，旧值会被保存到一条undo日志中，随着更新次数的增加，所有的版本都会通过<code>DB_ROLL_PTR</code>连接成一个链表，称之为<strong>版本链</strong>。</p></div><h3 id="read-view" tabindex="-1"><a class="header-anchor" href="#read-view"><span>Read View</span></a></h3><p>readview视图存在如下4个字段</p><ul><li><code>m_ids</code>：m_ids中维护了一个有序数组（升序），该数组保存了ReadView生成时，活跃的事务id</li><li><code>m_low_limit_id（max_trx_id）</code>：预分配事务id，等于当前最大事务id + 1（事务是自增的）</li><li><code>m_up_limit_id（min_trx_id）</code>：最小活跃事务id</li><li><code>m_creator_trx_id</code>：ReadView创建者的id</li></ul><div class="hint-container important"><p class="hint-container-title">Read View 与事务隔离级别</p><p>不同的事务隔离级别会影响 Read View 的行为：</p><ul><li><p><strong>READ COMMITTED</strong>：每次SELECT都会创建一个新的<code>ReadView</code>，能看到已提交的数据版本</p></li><li><p><strong>REPEATABLE READ</strong>（默认）：在整个事务期间保持同一个<code>ReadView</code>，多次查询结果一致</p></li></ul></div><h3 id="可见性规则" tabindex="-1"><a class="header-anchor" href="#可见性规则"><span>可见性规则</span></a></h3><ul><li><p>如果被访问版本的 <code>DB_TRX_ID</code> 属性值与 Read View 中的 <code>m_creator_trx_id</code> 值相同，表示当前事务正在访问自己所修改的记录，因此该版本<strong>可以被当前事务访问</strong>。</p></li><li><p>如果被访问版本的 <code>DB_TRX_ID</code> 属性值小于 Read View 中的 <code>m_up_limit_id</code> 值，说明生成该版本的事务在当前事务生成 Read View 之前已经提交，因此该版本<strong>可以被当前事务访问</strong>。</p></li><li><p>如果被访问版本的 <code>DB_TRX_ID</code> 属性值大于或等于 Read View 中的 <code>m_low_limit_id</code> 值，说明生成该版本的事务在当前事务生成 Read View 之后才提交，因此该版本<strong>不能被当前事务访问</strong>。</p></li><li><p>如果被访问版本的 <code>DB_TRX_ID</code> 属性值位于 Read View 的 <code>m_up_limit_id</code> 和 <code>m_low_limit_id</code> 之间（包括边界），则需要进一步检查 <code>DB_TRX_ID</code> 是否在<code>m_ids</code> 列表中。</p><ul><li>如果在列表中（创建ReadView时生成该版本的事务仍处于活跃状态）该版本<strong>不能被访问</strong></li><li>如果不在列表中（创建 Read View 时生成该版本的事务已经提交）该版本<strong>可以被访问</strong></li></ul></li></ul><p>如果经过上面的判断目标版本不能被访问，则继续沿着版本链判断下一条 Undo Log</p><h3 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例</span></a></h3><h3 id="快照读与当前读" tabindex="-1"><a class="header-anchor" href="#快照读与当前读"><span>快照读与当前读</span></a></h3><p><strong>快照读快照读（Snapshot Read）</strong>： 指读取一个事务开始时的数据快照，而不是最新的数据。这意味着它不会看到其他事务在此事务启动后所做的任何更改，即使这些更改已经被提交。</p><p>默认情况下，SELECT 是非锁定的一致性读（consistent nonlocking read）。这种类型的读取能够提高并发性能，因为它允许多个事务同时读取而不会相互阻塞。</p><ul><li><p><code>REPEATABLE-READ</code>级别: 事务begin后，第一条SELECT语句会创建一个快照，读取满足可见性的数据，之后该事务会一直用这个快照，直到事务结束</p></li><li><p><code>READ-COMMITTED</code>级别: 事务begin后，每条SELECT语句都会重置快照(重新创建快照)， 读取当前满足可见性的数据</p></li></ul><p><strong>当前读（Current Read）</strong>：总是读取最新的、已经提交的数据版本。这不仅包括了本事务所做的更改，也包括所有其他已经提交事务的结果。</p><p>为了确保读取到最新数据，当前读可能会加锁以防止其他事务对所读取的数据进行修改。因此，当前读通常是锁定读（locking read），即在读取的同时还会获取适当的锁来保护数据的一致性和完整性。主要包括以下几种情况：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ... LOCK </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">IN</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> SHARE MODE;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ... </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FOR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> SHARE;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ... </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FOR</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> UPDATE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INSERT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ... ;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">UPDATE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ... ;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DELETE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ... ;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>MySQL中当前读一般说的就是基于事务的<strong>一致性读（Consistent Read）</strong> 和 <strong>锁定读（Locking Read）</strong></p><p>快照读查看的是事务开始时的数据快照，而当前读则总是读取最新的已提交数据。</p><div class="hint-container info"><p class="hint-container-title">MVCC机制核心概念</p><h4 id="_1-回滚日志-undo-log" tabindex="-1"><a class="header-anchor" href="#_1-回滚日志-undo-log"><span>1. 回滚日志（Undo Log）</span></a></h4><ul><li><strong>插入回滚段</strong>：记录插入操作的旧版本，用于回滚。</li><li><strong>更新回滚段</strong>：记录更新操作的旧版本，用于回滚和多版本并发控制。</li></ul><h4 id="_2-读视图-read-view" tabindex="-1"><a class="header-anchor" href="#_2-读视图-read-view"><span>2. 读视图（Read View）</span></a></h4><p>读视图是一个事务在开始时创建的一个快照，记录了当前活动事务的ID列表。读视图包含以下几个重要信息：</p><ul><li><strong>m_ids</strong>：当前活动事务的ID列表。</li><li><strong>min_trx_id</strong>：最小的活动事务ID。</li><li><strong>max_trx_id</strong>：最大的活动事务ID。</li><li><strong>creator_trx_id</strong>：创建读视图的事务ID。</li></ul><h4 id="_3-版本链-version-chain" tabindex="-1"><a class="header-anchor" href="#_3-版本链-version-chain"><span>3. 版本链（Version Chain）</span></a></h4><p>每个数据行都有一个版本链，记录了该行的历史版本。版本链中的每个版本都包含一个事务ID（TXID），表示该版本是由哪个事务创建的。版本链中的每个版本还包含指向下一个版本的指针。</p><h4 id="_4-当前事务id的比较规则" tabindex="-1"><a class="header-anchor" href="#_4-当前事务id的比较规则"><span>4. 当前事务ID的比较规则</span></a></h4><p>在 <code>Repeatable Read</code> 隔离级别下，判断某个版本是否对当前事务可见的规则如下：</p><ol><li><strong>版本的事务ID小于读视图的最小事务ID</strong>：版本对当前事务可见。</li><li><strong>版本的事务ID大于读视图的最大事务ID</strong>：版本对当前事务不可见。</li><li><strong>版本的事务ID在读视图的活动事务ID列表中</strong>：版本对当前事务不可见。</li></ol></div><details class="hint-container details"><summary>MVCC 机制的工作流程示例</summary><p>假设有一个表 <code>employees</code>，初始状态如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>| id | name  | salary | DB_TRX_ID | DB_ROLL_PTR |</span></span>
<span class="line"><span>|----|-------|--------|-----------|-------------|</span></span>
<span class="line"><span>| 1  | Alice | 50000  | 0         | NULL        |</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="事务1开始" tabindex="-1"><a class="header-anchor" href="#事务1开始"><span>事务1开始</span></a></h4><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">BEGIN</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="事务1更新数据" tabindex="-1"><a class="header-anchor" href="#事务1更新数据"><span>事务1更新数据</span></a></h4><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">UPDATE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> employees </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SET</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> salary </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 60000</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此时，表的状态变为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>| id | name  | salary | DB_TRX_ID | DB_ROLL_PTR |</span></span>
<span class="line"><span>|----|-------|--------|-----------|-------------|</span></span>
<span class="line"><span>| 1  | Alice | 60000  | 1         | ptr1        |</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>DB_TRX_ID</strong>：1（事务1的ID）</li><li><strong>DB_ROLL_PTR</strong>：ptr1（指向旧版本的指针）</li></ul><p>旧版本存储在回滚段中：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>| id | name  | salary | DB_TRX_ID | DB_ROLL_PTR |</span></span>
<span class="line"><span>|----|-------|--------|-----------|-------------|</span></span>
<span class="line"><span>| 1  | Alice | 50000  | 0         | NULL        |</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="事务2开始" tabindex="-1"><a class="header-anchor" href="#事务2开始"><span>事务2开始</span></a></h4><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">BEGIN</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="事务2查询数据" tabindex="-1"><a class="header-anchor" href="#事务2查询数据"><span>事务2查询数据</span></a></h4><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> employees </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h5 id="处理流程" tabindex="-1"><a class="header-anchor" href="#处理流程"><span>处理流程</span></a></h5><ol><li><p><strong>事务2创建读视图</strong>：</p><ul><li><strong>m_ids</strong>：[1] （当前系统中未提交的事务ID列表）</li><li><strong>min_trx_id</strong>：1 （m_ids 列表中的最小值）</li><li><strong>max_trx_id</strong>：1 （m_ids 列表中的最大值）</li><li><strong>creator_trx_id</strong>：2（创建读视图的事务ID）</li></ul></li><li><p><strong>事务2查找数据行</strong>：</p><ul><li>当前数据行的版本：<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>| id | name  | salary | DB_TRX_ID | DB_ROLL_PTR |</span></span>
<span class="line"><span>|----|-------|--------|-----------|-------------|</span></span>
<span class="line"><span>| 1  | Alice | 60000  | 1         | ptr1        |</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>DB_TRX_ID （1）是否小于读视图的最小事务ID（1）：不是。 --&gt; 不可见</li><li>DB_TRX_ID （1）是否大于读视图的最大事务ID（1）：不是。</li><li>DB_TRX_ID （1）是否在读视图的活动事务ID列表中（[1]）：是。</li><li>因此，当前版本对事务2不可见。</li></ul></li><li><p><strong>事务2查找旧版本</strong>：</p><ul><li>通过 <strong>DB_ROLL_PTR</strong>（ptr1）找到旧版本：<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>| id | name  | salary | DB_TRX_ID | DB_ROLL_PTR |</span></span>
<span class="line"><span>|----|-------|--------|-----------|-------------|</span></span>
<span class="line"><span>| 1  | Alice | 50000  | 0         | NULL        |</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>检查旧版本的事务ID（0）是否小于等于读视图的最小事务ID（1）：是。</li><li>因此，旧版本对事务2可见。</li></ul></li><li><p><strong>事务2返回查询结果</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>| id | name  | salary |</span></span>
<span class="line"><span>|----|-------|--------|</span></span>
<span class="line"><span>| 1  | Alice | 50000  |</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol></details><p>在 MySQL InnoDB 存储引擎中，<code>读已提交</code>（Read Committed，RC）和<code>可重复读</code>（Repeatable Read，RR）的本质区别：</p><ul><li><strong>读已提交（RC）</strong>：<mark>每次查询创建新的读视图</mark>，事务内的多次查询可能会看到不同的数据版本。</li><li><strong>可重复读（RR）</strong>：事务开始时创建读视图，事务内的多次查询会看到相同的快照。</li></ul><p>因此在MVCC机制中，在可重复读隔离级别下同一个事务内多次查询使用的均是同一个视图，解决了不可重读的问题。</p><p>需要注意的是，这里在第二个事务中均是读数据的操作，若要更新数据，是需要对记录加锁的，否则可能会导致数据最终不正确。</p><p>参照Blog：<a href="https://blog.csdn.net/qq_62835094/article/details/136669636" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_62835094/article/details/136669636</a></p><h2 id="mysql锁的分类" tabindex="-1"><a class="header-anchor" href="#mysql锁的分类"><span>MySQL锁的分类</span></a></h2><p>在 MySQL 中，锁机制是保证数据一致性和并发控制的重要手段。根据不同的角度，MySQL 中的锁可以分为多种类型。</p><div class="hint-container info"><p class="hint-container-title">MySQL-Lock</p><h4 id="_1-按照锁的粒度分类" tabindex="-1"><a class="header-anchor" href="#_1-按照锁的粒度分类"><span>1. 按照锁的粒度分类</span></a></h4><ul><li>表级锁（Table-Level Locks）: 锁住整张表，影响范围较大，但开销较小。<br> 可以通过 <code>LOCK TABLES</code> 和 <code>UNLOCK TABLES</code> 显式地对表进行加锁和解锁。</li><li>行级锁（Row-Level Locks）: 锁住表中的特定行，影响范围较小，但开销较大。<br> 可以通过 <code>SELECT ... FOR UPDATE</code> 或 <code>SELECT ... FOR SHARE</code> 显式地对行进行加锁。<div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> table_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> FOR</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> UPDATE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> table_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> FOR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> SHARE;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li>页面锁（Page-Level Locks）: 锁住表中的特定页面，介于表级锁和行级锁之间。<br> 在 BDB 存储引擎中使用页面锁，但现在很少使用 BDB 存储引擎。</li></ul><h4 id="_2-按照锁的性质分类" tabindex="-1"><a class="header-anchor" href="#_2-按照锁的性质分类"><span>2. 按照锁的性质分类</span></a></h4><ul><li>共享锁（Shared Locks，S 锁）: 允许多个事务同时持有共享锁<br> 可以通过 <code>SELECT ... FOR SHARE</code> 显式地获取共享锁。<div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> table_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> FOR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> SHARE;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li>排他锁（Exclusive Locks，X 锁）：只允许一个事务持有排他锁，阻止其他事务的任何操作。<br> 可以通过 <code>SELECT ... FOR UPDATE</code> 显式地获取排他锁。<div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> table_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> FOR</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> UPDATE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li>意向锁（Intent Locks）: 表示对表或页面的锁定意图。在 InnoDB 存储引擎中自动使用。 <ul><li><strong>意向共享锁（IS 锁）</strong>：表示事务打算对表中的某些行获取共享锁。</li><li><strong>意向排他锁（IX 锁）</strong>：表示事务打算对表中的某些行获取排他锁。</li></ul></li></ul><h4 id="_3-按照锁的作用范围分类" tabindex="-1"><a class="header-anchor" href="#_3-按照锁的作用范围分类"><span>3. 按照锁的作用范围分类</span></a></h4><ul><li>记录锁（Record Locks）: 锁住索引记录。</li><li>间隙锁（Gap Locks）: 锁住索引记录之间的间隙。在 InnoDB 存储引擎中自动使用，主要用于防止幻读。</li><li>临键锁（记录+间隙锁）（Next-Key Locks）：同时锁住索引记录和其前一个间隙。在 InnoDB 存储引擎中自动使用，主要用于防止幻读。</li></ul></div><p>在 MySQL InnoDB 存储引擎中，间隙锁（Gap Locks）和临键锁（Next-Key Locks）是用于解决幻读问题的关键机制。</p><ul><li><p><strong>间隙锁</strong>：锁住索引记录之间的间隙，而不是具体的记录。防止其他事务在这段间隙中插入新的记录</p><ul><li>锁住的范围：间隙锁锁住的是索引记录之间的空白区域。<br> 例：假设有一个索引包含以下记录：1, 4, 7。间隙锁可以锁住以下间隙：<br><code>(负无穷, 1) (1, 4) (4, 7) (7, 正无穷)</code></li><li>在 <code>可重复读</code>（Repeatable Read）隔离级别下，InnoDB 自动使用间隙锁来防止幻读。通常不需要手动使用间隙锁，但可以通过 <code>SELECT ... FOR UPDATE</code>间接触发。</li></ul></li><li><p><strong>临键锁</strong>：同时锁住索引记录和其前一个间隙。临键锁是记录锁和间隙锁的组合。</p><ul><li>锁住的范围：临键锁不仅锁住具体的索引记录，还锁住该记录之前的所有间隙。<br> 例：假设有一个索引包含以下记录：1, 4, 7。临键锁可以锁住以下范围：<br><code> (负无穷, 1]（包括1） (1, 4]（包括4）(4, 7]（包括7）(7, 正无穷]</code></li><li>在 <code>可重复读</code>（Repeatable Read）隔离级别下，InnoDB 自动使用临键锁来防止幻读。通常不需要手动使用临键锁，但可以通过 <code>SELECT ... FOR UPDATE</code>间接触发。</li></ul></li></ul><p><strong>如何解决幻读</strong>：在一个事务中，多次执行相同的查询，但结果集却不同。这是因为其他事务在这段时间内插入了新的记录。而间隙锁和临键锁的作用：</p><ul><li><strong>防止插入新记录</strong>：通过锁住索引记录之间的间隙，间隙锁和临键锁可以防止其他事务在这段间隙中插入新的记录。</li><li><strong>保持事务的一致性</strong>：确保事务内的多次查询结果一致，避免幻读现象。</li></ul><details class="hint-container details"><summary>解决幻读示例</summary><p>假设有一个表 <code>employees</code>，初始状态如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>| id | name  | salary |</span></span>
<span class="line"><span>|----|-------|--------|</span></span>
<span class="line"><span>| 1  | Alice | 50000  |</span></span>
<span class="line"><span>| 4  | Bob   | 60000  |</span></span>
<span class="line"><span>| 7  | Carol | 70000  |</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><p><strong>事务1开始</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">BEGIN</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>事务1查询数据</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> employees </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">BETWEEN</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 7</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> FOR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> SHARE;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>事务1获取了临键锁，锁住了 (负无穷, 1]、(1, 4] 和 (4, 7]。</li></ul></li><li><p><strong>事务2开始</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">BEGIN</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>事务2尝试插入数据</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INSERT INTO</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> employees (id, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, salary) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">VALUES</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;David&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">55000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>由于事务1已经锁住了 (4, 7]，事务2会被阻塞，直到事务1提交或回滚。</li></ul></li><li><p><strong>事务1提交</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">COMMIT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>事务2再次尝试插入数据</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INSERT INTO</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> employees (id, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, salary) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">VALUES</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;David&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">55000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>事务2成功插入数据，因为事务1已经提交，临键锁被释放。</li></ul></li></ol></details><p>通过使用临键锁，InnoDB 存储引擎在 <code>可重复读</code> 隔离级别下有效地解决了幻读问题。</p>`,65)]))}const p=s(l,[["render",t],["__file","Transaction.html.vue"]]),o=JSON.parse('{"path":"/java/database/db/Transaction.html","title":"事务与锁机制","lang":"en-US","frontmatter":{"order":15,"title":"事务与锁机制","description":"MySQL Transaction 事务（Transaction）：是由一系列对数据库中数据进⾏访问（查询）与更新（增删改）的操作所组成的⼀个程序执行逻辑单元。这些操作，要么都成功，要么都不成功。 事务的ACID特性 事务具有四个重要特征：原子性（Atomicity），一致性（Consistency），隔离性（Isolation），持久性（Durabi...","head":[["meta",{"property":"og:url","content":"https://x.app/java/database/db/Transaction.html"}],["meta",{"property":"og:site_name","content":"Home"}],["meta",{"property":"og:title","content":"事务与锁机制"}],["meta",{"property":"og:description","content":"MySQL Transaction 事务（Transaction）：是由一系列对数据库中数据进⾏访问（查询）与更新（增删改）的操作所组成的⼀个程序执行逻辑单元。这些操作，要么都成功，要么都不成功。 事务的ACID特性 事务具有四个重要特征：原子性（Atomicity），一致性（Consistency），隔离性（Isolation），持久性（Durabi..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://image.ventix.top/img02/20220119212913677.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-01-19T15:33:28.000Z"}],["meta",{"property":"article:author","content":"ventixy"}],["meta",{"property":"article:modified_time","content":"2025-01-19T15:33:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"事务与锁机制\\",\\"image\\":[\\"https://image.ventix.top/img02/20220119212913677.png\\"],\\"dateModified\\":\\"2025-01-19T15:33:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ventixy\\",\\"url\\":\\"https://www.ventix.top\\"}]}"]]},"headers":[{"level":2,"title":"MySQL Transaction","slug":"mysql-transaction","link":"#mysql-transaction","children":[{"level":3,"title":"事务的ACID特性","slug":"事务的acid特性","link":"#事务的acid特性","children":[]},{"level":3,"title":"事务的并发问题","slug":"事务的并发问题","link":"#事务的并发问题","children":[]},{"level":3,"title":"事务的隔离级别","slug":"事务的隔离级别","link":"#事务的隔离级别","children":[]}]},{"level":2,"title":"MVCC机制详解","slug":"mvcc机制详解","link":"#mvcc机制详解","children":[{"level":3,"title":"数据行隐藏字段","slug":"数据行隐藏字段","link":"#数据行隐藏字段","children":[]},{"level":3,"title":"UndoLog与版本链","slug":"undolog与版本链","link":"#undolog与版本链","children":[]},{"level":3,"title":"Read View","slug":"read-view","link":"#read-view","children":[]},{"level":3,"title":"可见性规则","slug":"可见性规则","link":"#可见性规则","children":[]},{"level":3,"title":"示例","slug":"示例","link":"#示例","children":[]},{"level":3,"title":"快照读与当前读","slug":"快照读与当前读","link":"#快照读与当前读","children":[]}]},{"level":2,"title":"MySQL锁的分类","slug":"mysql锁的分类","link":"#mysql锁的分类","children":[]}],"git":{"createdTime":1737300808000,"updatedTime":1737300808000,"contributors":[{"name":"drizzle","email":"msdrizzle@outlook.com","commits":1}]},"readingTime":{"minutes":20.33,"words":6100},"filePathRelative":"java/database/db/Transaction.md","localizedDate":"January 19, 2025","excerpt":"<h2>MySQL Transaction</h2>\\n<p><strong>事务（Transaction）</strong>：是由一系列对数据库中数据进⾏访问（查询）与更新（增删改）的操作所组成的⼀个程序执行逻辑单元。这些操作，要么都成功，要么都不成功。</p>\\n<div class=\\"language-sql line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"sql\\" data-title=\\"sql\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">-- 事务相关命令：</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">begin</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">;                </span><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">-- 开始，还可以使用下列语法：</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">start transaction</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">; </span></span>\\n<span class=\\"line\\"></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">commit</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">;               </span><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">-- 提交：使得当前的修改确认</span></span>\\n<span class=\\"line\\"></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">rollback</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">;             </span><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">-- 回滚：使得当前的修改被放弃</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{p as comp,o as data};
