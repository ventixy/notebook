import{_ as k}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,b as t,d,w as n,r,o as g,e as s,a as i}from"./app-xMhgd-IM.js";const A={};function c(o,a){const h=r("Tabs");return g(),p("div",null,[a[4]||(a[4]=t(`<h2 id="sql调优理论基础" tabindex="-1"><a class="header-anchor" href="#sql调优理论基础"><span>SQL调优理论基础</span></a></h2><h3 id="索引数据结构" tabindex="-1"><a class="header-anchor" href="#索引数据结构"><span>索引数据结构</span></a></h3><p>数据库索引是提高数据库查询性能的关键技术之一。索引类似于书籍的目录，通过索引可以快速定位到所需的数据，而不需要扫描整个表。</p><details class="hint-container details"><summary>数据库索引的优缺点</summary><h4 id="索引的优点" tabindex="-1"><a class="header-anchor" href="#索引的优点"><span>索引的优点</span></a></h4><ol><li><strong>提高查询速度</strong>：通过索引，数据库引擎可以快速定位到所需的数据，而不需要扫描整个表。</li><li><strong>提高排序和分组效率</strong>：索引可以加速排序和分组操作。</li><li><strong>唯一性约束</strong>：唯一索引可以确保数据的唯一性，防止重复数据的插入。</li></ol><h4 id="索引的缺点" tabindex="-1"><a class="header-anchor" href="#索引的缺点"><span>索引的缺点</span></a></h4><ol><li><strong>增加存储空间</strong>：索引需要额外的存储空间，尤其是大型表和多列索引。</li><li><strong>降低写操作性能</strong>：插入、更新和删除操作需要维护索引，增加了这些操作的开销。</li><li><strong>复杂性</strong>：过多的索引会使数据库设计和维护变得复杂。</li></ol></details><p>为什么索引就更快呢? 这就要探究索引使用的数据结构了</p><div class="hint-container info"><p class="hint-container-title">常见的可作为索引的数据结构</p><h4 id="_1-数组和链表" tabindex="-1"><a class="header-anchor" href="#_1-数组和链表"><span>1. 数组和链表</span></a></h4><figure><img src="https://image.ventix.top/java/image-20220324204029868.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_2-hash表" tabindex="-1"><a class="header-anchor" href="#_2-hash表"><span>2. hash表</span></a></h4><figure><img src="https://image.ventix.top/java/image-20220324205314504.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_3-二叉树" tabindex="-1"><a class="header-anchor" href="#_3-二叉树"><span>3. 二叉树</span></a></h4><figure><img src="https://image.ventix.top/java/image-20220324204347069.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>可以适当的帮助我们提高查询单个值的效率</li><li>可以适当的帮助我们提高查询范围值的效率</li></ul><p>二叉树（包括AVL树、红黑树）对于提升查询效率的帮助是十分有限的。为什么呢？</p><p>因为这些树只有两个“叉”，当数据变多的时候，树的层高会急剧上升，这就会导致搜索的困难增加，效率会明显降低。</p><h4 id="_4-b树和b-树" tabindex="-1"><a class="header-anchor" href="#_4-b树和b-树"><span>4. B树和B+树</span></a></h4><figure><img src="https://image.ventix.top/java/image-20220324204721606.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><br><figure><img src="https://image.ventix.top/java/image-20220324204910192.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><ul><li>在数据库中B+树的高度一般都在2～4层，也就是说查找某一行记录时最多只需要2到4次IO</li><li>B+树索引的主要特点在于： <ul><li><mark>非叶子节点只存储关键字和子节点指针</mark>：非叶子节点用于引导查找，存储关键字和指向子节点的指针，但不存储数据记录。</li><li><mark>所有叶子节点包含关键字和数据指针</mark>：在 B+树中，所有的数据记录都存储在叶子节点中，而非叶子节点只存储关键字和指向子节点的指针。</li><li><mark>所有叶子节点通过指针链接在一起</mark>：叶子节点之间通过指针链接，形成一个双向链表，便于范围查询。</li></ul></li></ul><h3 id="b-树索引" tabindex="-1"><a class="header-anchor" href="#b-树索引"><span>B+树索引</span></a></h3><p>B+树（B+ Tree）是一种广泛应用于数据库和文件系统中的数据结构，特别适合于磁盘存储和检索大量数据。B+树的设计目标是减少磁盘 I/O 操作次数，从而提高数据检索的效率。B+树的特点：</p><ol><li><strong>高度平衡</strong>：B+树是高度平衡的树，所有叶子节点都在同一层，保证了查找、插入和删除操作的时间复杂度为 <code>O(log n)</code>。</li><li><strong>高效的空间利用率</strong>：每个节点可以存储多个关键字和指针，减少了磁盘 I/O 操作次数。</li><li><strong>支持范围查询</strong>：由于叶子节点通过指针链接在一起，B+树非常适合进行范围查询。</li><li><strong>数据集中存储</strong>：所有数据记录都存储在叶子节点中，非叶子节点只用于引导查找，提高了查找效率。</li></ol><div class="hint-container info"><p class="hint-container-title">B+树的节点结构</p><ol><li><p><strong>内部节点（非叶子节点）</strong>：</p><ul><li>存储关键字和指向子节点的指针。</li><li>关键字用于引导查找，指针指向子节点。</li><li>每个内部节点最多有 M 个子节点，最少有 M/2 个子节点（其中M是节点的最大度数）。</li></ul></li><li><p><strong>叶子节点</strong>：</p><ul><li>存储关键字和数据记录（或数据记录的指针）。</li><li>通过指针链接在一起，形成一个双向链表。</li><li>每个叶子节点最多有 L个关键字，最少有 L/2个关键字（其中L是节点的最大容量）。</li></ul></li></ol></div><details class="hint-container details"><summary>B+树的插入与删除</summary><h4 id="插入操作" tabindex="-1"><a class="header-anchor" href="#插入操作"><span>插入操作</span></a></h4><ol><li><strong>查找插入位置</strong>：从根节点开始，根据关键字递归查找插入位置，直到找到合适的叶子节点。</li><li><strong>插入关键字和数据</strong>：在叶子节点中插入关键字和数据记录。</li><li><strong>分裂节点</strong>：如果叶子节点已满，需要分裂节点，将一半的关键字和数据记录移到新节点中，并在父节点中插入新的关键字和指针。</li><li><strong>更新父节点</strong>：如果父节点也满了，继续向上分裂，直到根节点或某个节点不再需要分裂。</li></ol><h4 id="删除操作" tabindex="-1"><a class="header-anchor" href="#删除操作"><span>删除操作</span></a></h4><ol><li><strong>查找删除位置</strong>：从根节点开始，根据关键字递归查找删除位置，直到找到合适的叶子节点。</li><li><strong>删除关键字和数据</strong>：在叶子节点中删除关键字和数据记录。</li><li><strong>合并节点</strong>：如果叶子节点中的关键字数量少于最小值，需要从兄弟节点借关键字或合并节点。</li><li><strong>更新父节点</strong>：如果父节点中的关键字数量少于最小值，继续向上合并，直到根节点或某个节点不再需要合并。</li></ol></details><p>B+树索引可以分为聚集索引（clustered inex）和 非聚集索引（secondary index，辅助索引）</p><div class="hint-container tip"><p class="hint-container-title">聚集索引（clustered inex） 和 非聚集索引（secondary index）</p><p>聚集索引（Clustered Index）和非聚集索引（Secondary Index）是数据库中两种重要的索引类型，它们在数据存储和查询性能方面有着显著的区别。</p><h4 id="聚集索引-clustered-index" tabindex="-1"><a class="header-anchor" href="#聚集索引-clustered-index"><span>聚集索引（Clustered Index）</span></a></h4><p>聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。</p><ul><li><p>数据页上存放的是完整的每行的记录，而在非数据页的索引页中，存放的仅仅是键值及指向数据页的偏移量，而不是一个完整的行记录。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。</p></li><li><p>聚集索引的一个好处就是，它对于主键的排序查找和范围查找速度非常快。叶子节点的数据就是用户所要查询的数据。</p></li><li><p>由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。<mark>主键通常用作聚集索引，因为主键是唯一的，适合按主键顺序存储数据</mark>。</p></li><li><p>在多数情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据。此外，由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值的查询。</p></li></ul><h4 id="非聚集索引-secondary-index" tabindex="-1"><a class="header-anchor" href="#非聚集索引-secondary-index"><span>非聚集索引（Secondary Index）</span></a></h4><p>辅助索引（Secondary Index），也称非聚集索引（non-clustered index）。其叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签（bookmark）</p><p>示例:</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> employees</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    employee_id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INT</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> PRIMARY KEY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,      </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 聚集索引</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    first_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">VARCHAR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">50</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    last_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">VARCHAR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">50</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    hire_date </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DATE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    INDEX</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> idx_last_name (last_name),  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 非聚集索引</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    INDEX</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> idx_hire_date (hire_date)   </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 非聚集索引</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>聚集索引 vs 非聚集索引</strong></p><table><thead><tr><th>特点</th><th>聚集索引（Clustered Index）</th><th>非聚集索引（Secondary Index）</th></tr></thead><tbody><tr><td><strong>物理存储</strong></td><td>数据行按索引键顺序存储</td><td>索引键和指向数据行的指针</td></tr><tr><td><strong>数量限制</strong></td><td>一个表只能有一个聚集索引</td><td>一个表可以有多个非聚集索引</td></tr><tr><td><strong>查询性能</strong></td><td>范围查询和排序查询性能高</td><td>需要额外的 I/O 操作，但灵活性高</td></tr><tr><td><strong>插入和更新开销</strong></td><td>插入和更新可能导致数据行重新排序</td><td>插入和更新开销相对较小</td></tr><tr><td><strong>应用场景</strong></td><td>主键索引、范围查询、排序查询</td><td>多列查询、覆盖索引、辅助查询</td></tr></tbody></table></div><p>【注】许多数据库的文档会这样告诉读者：聚集索引按照顺序物理地存储数据。但是试想一下，如果聚集索引必须按照特定顺序存放物理记录，则维护成本显得非常之高。所以，聚集索引的存储并不是物理上连续的，而是逻辑上连续的。这其中有两点：</p><ul><li><p>一是页通过双向链表链接，页按照主键的顺序排序；</p></li><li><p>另一点是每个页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。</p></li></ul><div class="hint-container info"><p class="hint-container-title">B+树索引的应用场景</p><ol><li><strong>数据库索引</strong>：B+树广泛用于数据库的索引结构，如 MySQL 的 InnoDB 存储引擎。</li><li><strong>文件系统</strong>：B+树用于文件系统的目录结构，如 NTFS 文件系统。</li><li><strong>搜索引擎</strong>：B+树用于索引大量的文档和网页，支持高效的检索操作。</li><li><strong>内存数据库</strong>：B+树也用于内存数据库中，如 Redis 的有序集合。</li></ol></div><h3 id="回表-覆盖索引" tabindex="-1"><a class="header-anchor" href="#回表-覆盖索引"><span>回表/覆盖索引</span></a></h3><p><strong>回表（Table Lookup）</strong> 是指在使用非聚集索引（Secondary Index）进行查询时，数据库引擎需要先通过非聚集索引找到数据行的指针，然后再访问实际的数据行的过程(即需要再返回到主键索引树查询一次)。</p><div class="hint-container tip"><p class="hint-container-title">如何避免回表呢？</p><ol><li><p>尽量避免写 <code>select *</code> ，仅查询需要的字段，如果这些字段均包含在索引字段内且符合最左前缀原则，就可以不用回表了</p></li><li><p>合理设计索引，可以考虑使用联合索引</p></li></ol></div><p><strong>联合索引</strong>：针对多列值来构建B+树。（若查询的所有列是一个联合索引，则使用非聚集索引一次就可以查询到数据），也可以称这种方式为：<mark>覆盖索引</mark> （即将被查询的字段建立到联合索引中）</p><div class="hint-container info"><p class="hint-container-title">覆盖索引</p><p>最左前缀原则的一个重要应用是覆盖索引（Covering Index）。覆盖索引是指查询条件和返回结果都在索引列中，数据库引擎可以直接从索引中获取数据，而不需要访问实际的数据行。</p><p>示例: 假设有一个表 <code>orders</code>，并且在 <code>(customer_id, order_date, order_amount)</code> 上创建了一个组合索引：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> orders</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    order_id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INT</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> PRIMARY KEY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    customer_id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    order_date </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DATE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    order_amount </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DECIMAL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    INDEX</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> idx_customer_order (customer_id, order_date, order_amount)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以下查询可以利用覆盖索引：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> order_date, order_amount </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> customer_id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 123</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个查询的条件 <code>customer_id</code> 是索引的最左列，返回的结果 <code>order_date</code> 和 <code>order_amount</code> 也在索引列中，因此可以利用覆盖索引，提高查询性能。</p></div><h3 id="最左前缀原则" tabindex="-1"><a class="header-anchor" href="#最左前缀原则"><span>最左前缀原则</span></a></h3><p>最左前缀原则指的是在组合索引中，查询条件必须从索引的最左边的列开始匹配，才能有效利用索引。换句话说，查询条件中的列必须是索引列的前缀，这样才能利用索引进行快速查找。</p><div class="hint-container tip"><p class="hint-container-title">原理解释</p><p>组合索引是一个多列索引，索引的顺序决定了数据的存储顺序。数据库引擎在查找数据时，会按照索引列的顺序进行匹配。如果查询条件中的列不是索引列的前缀，那么数据库引擎无法利用索引进行快速查找，只能进行全表扫描。</p></div><p>示例：假设有一个表 <code>employees</code>，并且在 <code>(last_name, first_name, hire_date)</code> 上创建了一个组合索引：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> employees</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    employee_id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INT</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> PRIMARY KEY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    last_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">VARCHAR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">50</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    first_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">VARCHAR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">50</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    hire_date </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DATE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    INDEX</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> idx_last_first_hire (last_name, first_name, hire_date)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>有效利用索引的查询</strong>:</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 1. 完全匹配索引列 这个查询完全匹配了组合索引的所有列，可以充分利用索引。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> employees </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> last_name </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Smith&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                        AND</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> first_name </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;John&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> hire_date </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;2020-01-01&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 2. 部分匹配索引列  这个查询匹配了组合索引的前两列，也可以充分利用索引。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> employees </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> last_name </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Smith&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> first_name </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;John&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 3. 仅匹配最左列（也可以充分利用索引）</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> employees </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> last_name </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;Smith&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>无法有效利用索引的查询</strong>：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 跳过最左列 这个查询跳过了组合索引的第一列 \`last_name\`，无法有效利用索引，会导致全表扫描。</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> employees </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> first_name </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;John&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> hire_date </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;2020-01-01&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>总结</strong>:</p><ul><li><strong>最左前缀原则</strong>：查询条件必须从组合索引的最左边的列开始匹配，才能有效利用索引。</li><li><strong>有效利用索引的查询</strong>：完全匹配索引列、部分匹配索引列、仅匹配最左列。</li><li><strong>无法有效利用索引的查询</strong>：跳过最左列、仅匹配非最左列、不按顺序匹配。</li><li><strong>覆盖索引</strong>：查询条件和返回结果都在索引列中，可以提高查询性能。</li></ul><p>通过合理设计组合索引和遵循最左前缀原则，可以显著提高数据库的查询性能。</p><h3 id="数据库查询优化" tabindex="-1"><a class="header-anchor" href="#数据库查询优化"><span>数据库查询优化</span></a></h3><ul><li><p>对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引</p></li><li><p>应避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫 描，</p><p>如： select id from t where num is null 最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库</p><p>备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用NULL。</p></li><li><p>应避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则引擎将放弃使用索引而进行全表扫描。 -</p></li><li><p>应避免在 where 子句中使用or来连接条件，如果一个字段有索引,一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 如：</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> num</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> or</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> Name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;admin&#39;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 可以这样查询：</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> num </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">union all</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> Name</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;admin&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>in 和 not in 也要慎用，否则会导致全表扫描，如：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> num </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>对于连续的数值，能用 between 就不要用 in 了：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> t </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> num </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">between</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> and</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>很多时候用 exists 代替 in 是一个好的选择</p></li></ul><h2 id="mysql数据库调优" tabindex="-1"><a class="header-anchor" href="#mysql数据库调优"><span>MySQL数据库调优</span></a></h2><h3 id="索引及文件位置" tabindex="-1"><a class="header-anchor" href="#索引及文件位置"><span>索引及文件位置</span></a></h3><p>MySQL默认使用主键列作为索引（若不设置主键、mysql会自动设置一个隐藏列作为索引）</p><div class="hint-container tip"><p class="hint-container-title">数据和索引的存储位置</p><p>对于mac系统默认在 <code>/usr/local/mysql</code> 文件夹中，对于win系统默认在：<code>c:/programdata/mysql</code> (隐藏文件夹).</p><p>不在默认位置的情况下，一般是安装时初始化MySQL自定义了数据文件的存放位置，比如修改为安装目录的 data 目录下</p></div><p>存储文件的详细说明：</p><ul><li>InnoDB存储引擎的表∶将索引和数据存放在同一个文件里。<code> *.ibd</code></li><li>MyISAM存储引擎的表:索引和数据分开两个文件来存储。索引: <code> *.MYI</code> ; 数据: <code>.MYD</code></li></ul><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">使用InnoDB存储引擎的创建的表会生成两个文件：</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">	-</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 一个</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> \`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">.frm</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> 结尾的表结构定义文件，</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">	-</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 一个存放数据和索引的</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> \`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">.ibd</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> 文件</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">而使用MyISAM存储引擎的创建的表会生成三个文件：</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">	-</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 一个</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> \`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">.frm</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> 结尾的表结构定义文件，</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">	-</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 一个存放数据的</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> \`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">.myd</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> 文件</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">	-</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 一个存放索引的</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> \`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">.myi</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> 文件</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="mysql存储引擎" tabindex="-1"><a class="header-anchor" href="#mysql存储引擎"><span>MySQL存储引擎</span></a></h3><p>MySQL支持多种存储引擎。其中最常用的两种存储引擎是 InnoDB 和 MyISAM。</p><div class="hint-container info"><p class="hint-container-title">MySQL存储引擎：InnoDB和MyISAM</p><h4 id="innodb索引" tabindex="-1"><a class="header-anchor" href="#innodb索引"><span>InnoDB索引</span></a></h4><figure><img src="https://image.ventix.top/java/image-20220325121029629.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="myisam索引" tabindex="-1"><a class="header-anchor" href="#myisam索引"><span>MyISAM索引</span></a></h4><figure><img src="https://image.ventix.top/java/image-20220325121053355.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></div><p>InnoDB和MyISAM有什么区别？什么情况下使用MyISAM？</p><div class="hint-container tip"><p class="hint-container-title">InnoDB和MyISAM的区别</p><ol><li><p>InnoDB 支持事务，MyISAM不支持事务，对于 InnoDB，每条SQL语句都自动封装成事务，自动提交，影响速度</p></li><li><p>InnoDB 支持外键，MyISAM不支持外键</p></li><li><p>InnoDB 的主键索引是聚集索引，数据文件和索引存储在一起。MyISAM则全是非聚集索引，索引和数据文件是分离的<br> InnoDB 的存储文件是 frm 和 ibd，而MyISAM是 frm、myd、myi 三个文件。</p></li><li><p>InnoDB 不保存表的行数，<code>查询某张表的行数</code>时会全表扫描。MyISAM会保存整个表的行数，执行速度很快</p></li><li><p>InnoDB 支持表锁和行锁（默认），而 MyISAM支持表锁。<br> 行锁是指：锁的对象是一行数据、 表锁是指：锁的对象是一整张表<br> 行锁的效率比表锁的效率要高。锁的粒度越细，锁的效率越高。</p></li><li><p>InnoDB 表必须要有一个主键（如果用户不设置，那么引擎会自行设定一列[隐藏列]当做主键），MyISAM 则可以没有</p></li></ol><p>如何选择存储引擎？</p><ul><li><p>是否需要事务？如果不需要（如历史记录数据），则可以使用MyISAM 。绝大多数操作是否是查询？如果是，可以选择MyISAM，</p></li><li><p>有读也有写，则选择 InnoDB</p></li></ul></div><p>MySQL如何指定存储引擎？</p><ol><li>创建表时指定存储引擎</li></ol><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> employees</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    employee_id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INT</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> PRIMARY KEY</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    -- ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) ENGINE </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> InnoDB;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>修改现有表的存储引擎</li></ol><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ALTER</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TABLE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> employees ENGINE </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> MyISAM;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="3"><li>设置默认存储引擎<br> 在 MySQL 的配置文件（通常是 my.cnf 或 my.ini）中设置默认的存储引擎</li></ol><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[mysqld]</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">default-storage-engine</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> InnoDB</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以通过 SQL 语句设置默认存储引擎: <code>SET GLOBAL default_storage_engine = InnoDB;</code></p><div class="hint-container info"><p class="hint-container-title">查看默认存储引擎</p><p>可以使用 SHOW VARIABLES 语句来查看当前的默认存储引擎</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">SHOW VARIABLES </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">LIKE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;default_storage_engine&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>可以使用 SHOW CREATE TABLE 语句来查看特定表的存储引擎</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SHOW</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> CREATE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> TABLE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> table_name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></div><h3 id="索引的分类和创建" tabindex="-1"><a class="header-anchor" href="#索引的分类和创建"><span>索引的分类和创建</span></a></h3><ul><li><p>主键索引: 主键自带索引效果，也就意味着通过主键来查询表中的记录，性能是非常好的</p></li><li><p>普通索引:为普通列创建的索引。创建索引的命令∶</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> 索引名称</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 表名(列名) </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> idx_name</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> employees(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>唯一索引∶ 就像是唯一列，列中的数据是唯一的。比普通索引的性能要好</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> unique index</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> 索引名称</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 表名(列名)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> unique index</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> idx_unique_name</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> employees(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>联合索引(组合索引)∶ 一次性为表中的多个字段一起创建索引(一个联合索引建议不要超过5个列)</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> 索引名称</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 表(列1,列2,列3, ...)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> idx_name_age_position</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> employees(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, age, position);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>全文索引：进行查询的时候，数据源可能来自于不同的字段或者不同的表。MyISAM存储引擎支持全文索引</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">注意：在实际生产环境中，并不会使用MySQL提供的MyISAM存储引擎的全文索引功能来是实现全文查找。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">而是会使用第三方的搜索引擎中间件比如</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> \`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ElasticSearch</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">推荐</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">、</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Solr</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> 等。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><div class="hint-container info"><p class="hint-container-title">MySQL中创建/删除索引的方式</p><p>创建索引的三种方式：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 第一种方式：在执行create table时创建索引 </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> user_index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    id </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> auto_increment </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">primary key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,    </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 主键索引</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    first_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">varchar</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">16</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    last_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">varchar</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">16</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    id_card </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">varchar</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">18</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    information </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">text</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">225</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">),</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    key</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(first_name,last_name),     </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 联合索引 （索引名为第一列的列名）</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    unique</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(id_card),                </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 唯一索引 （只有一列时索引名与列名一致）</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    fulltext</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(information)           </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 全文索引</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    -- 还可以用如下方式：</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> index_first_name(first_name) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> btree </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 第二种方式：使用Alter table命令去增加索引</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">alter</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> table_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">add</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  index_name(column_list);</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 第三种方式：使用create index命令来创建</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">create</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> index_name</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> table_name(column_list);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>删除索引可以通过 <code>DROP INDEX</code> 语句或 <code>alter table</code>来完成：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">DROP</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> INDEX</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> index_name</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ON</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> table_name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">alter</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> table</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 表名</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  drop</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> index</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 索引名</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 查看表的全部索引</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">show</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> index</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 表名</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><h3 id="使用explain" tabindex="-1"><a class="header-anchor" href="#使用explain"><span>使用EXPLAIN</span></a></h3><p>在 SQL语句 前面加上 <code>explain</code> 关键字，MySQL 就不会真正去执行这条语句，而是模拟优化器执行 SQL 查询语句，最后会输出一系列的指标告诉我们这条语句的性能如何。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">EXPLAIN </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[EXTENDED]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> query;   </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- \`EXPLAIN\`：显示查询的执行计划。 </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                            -- \`EXTENDED\`：可选参数，显示更详细的执行计划信息。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">EXPLAIN 输出的字段及其含义</p><ol><li><p><strong>id</strong>：查询的标识符，表示查询的顺序。</p><ul><li>ID 越大的组，其执行优先级越高。ID 相同的为一组，其执行优先级按照其顺序由上到下</li><li>如果一个查询中有子查询，每个子查询会有一个独立的 id。</li></ul></li><li><p><strong>select_type</strong>：查询的类型，常见的值包括：</p><ul><li><code>SIMPLE</code>：简单查询，不包含子查询或 UNION。</li><li><code>PRIMARY</code>：最外层的查询。最外层查询会被标记为主查询</li><li><code>SUBQUERY</code>：子查询中的第一个 SELECT。</li><li><code>DERIVED</code>：派生表中的第一个 SELECT（即在 FROM 子句中出现的子查询）。</li><li><code>UNION</code>：UNION 中的第二个或后面的 SELECT。</li><li><code>DEPENDENT UNION</code>：依赖于外部查询的 UNION 中的第二个或后面的 SELECT。</li><li><code>UNCACHEABLE SUBQUERY</code>：不可缓存的子查询。</li></ul></li><li><p><strong>table</strong>：当前查询引用的表名。</p></li><li><p><strong>partitions</strong>：匹配的分区（如果表被分区）。</p></li><li><p><strong>type</strong>：访问类型，表示 MySQL 使用的连接类型，常见的值包括：</p><ul><li><code>system</code>：表只有一行记录，这是常量表。</li><li><code>const</code>：表最多只有一个匹配行，读取常数次，通常用于主键或唯一索引。</li><li><code>eq_ref</code>：唯一索引扫描，通常用于主键或唯一索引。</li><li><code>ref</code>：非唯一索引扫描，返回所有匹配某个值的行。</li><li><code>range</code>：索引范围扫描，例如 <code>BETWEEN</code>、<code>&gt;</code> 等。</li><li><code>index</code>：索引扫描。</li><li><code>index_merge</code>: 索引合并,指对多个索引分别进行条件扫描,然后将它们各自的结果进行合并</li><li><code>ALL</code>：全表扫描。</li><li><code>null</code>： 表示 MySQL 能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引</li></ul></li><li><p><strong>possible_keys</strong>：可能使用的索引列表。</p></li><li><p><strong>key</strong>：实际使用的索引。</p></li><li><p><strong>key_len</strong>：使用索引的长度。长度越短，索引越有效。</p></li><li><p><strong>ref</strong>：与索引比较的列或常量。</p></li><li><p><strong>rows</strong>：根据表统计信息和索引选择情况，估算出的访问行数。</p></li><li><p><strong>filtered</strong>： 表示通过索引过滤后的行数占总行数的百分比。</p></li><li><p><strong>Extra</strong>：包含额外的信息，常见的值包括：</p><ul><li><code>Using where</code>：使用 WHERE 子句进行过滤。</li><li><code>Using index</code>：使用覆盖索引，不需要回表。</li><li><code>Using temporary</code>：使用临时表。</li><li><code>Using filesort</code>：使用文件排序。</li><li><code>Using join buffer</code>：使用连接缓冲区。</li><li><code>Impossible WHERE</code>：WHERE 子句总是返回 FALSE，不会有任何结果。</li><li><code>No tables used</code>：查询中没有表，例如 <code>SELECT 1</code>。</li></ul></li></ol></div><p>通过 <code>EXPLAIN</code> 工具，可以深入了解查询的执行计划，从而优化查询性能。<br> 更多更详细的信息参考：<a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html" target="_blank" rel="noopener noreferrer">EXPLAIN</a></p><h3 id="开启慢查询日志" tabindex="-1"><a class="header-anchor" href="#开启慢查询日志"><span>开启慢查询日志</span></a></h3><p>MySQL 的慢查询日志（Slow Query Log）是一个非常有用的工具，可以帮助你识别那些执行时间较长的查询，从而优化数据库性能。</p>`,67)),d(h,{id:"956",data:[{id:"通过配置文件开启"},{id:"通过动态配置开启"}],active:0},{title0:n(({value:l,isActive:e})=>a[0]||(a[0]=[s("通过配置文件开启")])),title1:n(({value:l,isActive:e})=>a[1]||(a[1]=[s("通过动态配置开启")])),tab0:n(({value:l,isActive:e})=>a[2]||(a[2]=[i("p",null,[s("编辑 MySQL 的配置文件（通常是 "),i("code",null,"my.cnf"),s(" 或 "),i("code",null,"my.ini"),s("），添加或修改以下配置项：")],-1),i("div",{class:"language-ini line-numbers-mode","data-highlighter":"shiki","data-ext":"ini","data-title":"ini",style:{"--shiki-light":"#383A42","--shiki-dark":"#abb2bf","--shiki-light-bg":"#FAFAFA","--shiki-dark-bg":"#282c34"}},[i("pre",{class:"shiki shiki-themes one-light one-dark-pro vp-code"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"[mysqld]")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 开启慢查询日志")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#E45649","--shiki-dark":"#C678DD"}},"slow_query_log"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," ="),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#98C379"}}," 1")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 指定慢查询日志文件的路径")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#E45649","--shiki-dark":"#C678DD"}},"slow_query_log_file"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," ="),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#98C379"}}," /var/log/mysql/slow-query.log")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 设置慢查询的阈值（单位：秒，默认为10s）")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#E45649","--shiki-dark":"#C678DD"}},"long_query_time"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," ="),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#98C379"}}," 2")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 记录不使用索引的查询")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#E45649","--shiki-dark":"#C678DD"}},"log_queries_not_using_indexes"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," ="),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#98C379"}}," 1")])])]),i("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"})])],-1),i("p",null,"保存配置文件后，重启 MySQL 服务使配置生效：",-1),i("div",{class:"language-sh line-numbers-mode","data-highlighter":"shiki","data-ext":"sh","data-title":"sh",style:{"--shiki-light":"#383A42","--shiki-dark":"#abb2bf","--shiki-light-bg":"#FAFAFA","--shiki-dark-bg":"#282c34"}},[i("pre",{class:"shiki shiki-themes one-light one-dark-pro vp-code"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"sudo"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," systemctl"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," restart"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," mysql")])])]),i("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[i("div",{class:"line-number"})])],-1)])),tab1:n(({value:l,isActive:e})=>a[3]||(a[3]=[i("p",null,"如果你不想重启 MySQL 服务，可以通过动态配置来开启慢查询日志。登录到 MySQL 并执行以下命令：",-1),i("div",{class:"language-sql line-numbers-mode","data-highlighter":"shiki","data-ext":"sql","data-title":"sql",style:{"--shiki-light":"#383A42","--shiki-dark":"#abb2bf","--shiki-light-bg":"#FAFAFA","--shiki-dark-bg":"#282c34"}},[i("pre",{class:"shiki shiki-themes one-light one-dark-pro vp-code"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"-- 开启慢查询日志")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"SET"),i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}}," GLOBAL"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," slow_query_log "),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#56B6C2"}},"="),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," 'ON'"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},";")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"-- 指定慢查询日志文件的路径")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"SET"),i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}}," GLOBAL"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," slow_query_log_file "),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#56B6C2"}},"="),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," '/var/log/mysql/slow-query.log'"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},";")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"-- 设置慢查询的阈值（单位：秒）")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"SET"),i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}}," GLOBAL"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," long_query_time "),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#56B6C2"}},"="),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}}," 2"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},";")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"-- 记录不使用索引的查询")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}},"SET"),i("span",{style:{"--shiki-light":"#A626A4","--shiki-dark":"#C678DD"}}," GLOBAL"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," log_queries_not_using_indexes "),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#56B6C2"}},"="),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}}," 1"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},";")])])]),i("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"})])],-1)])),_:1}),a[5]||(a[5]=t(`<p>慢查询日志文件通常是一个文本文件，你可以使用文本编辑器或命令行工具来查看。</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" data-title="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">less</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /var/log/mysql/slow-query.log</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 或者使用 \`tail\` 命令查看最近的慢查询记录：</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">tail</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -n</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /var/log/mysql/slow-query.log</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>MySQL 提供了一个工具 <code>mysqldumpslow</code> 来分析慢查询日志。这个工具可以帮助你汇总和分析慢查询日志，找出最耗时的查询。</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" data-title="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mysqldumpslow</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /var/log/mysql/slow-query.log</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>也可以使用第三方工具如 <code>pt-query-digest</code>（Percona Toolkit 的一部分）来分析慢查询日志：</p><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" data-title="sh" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pt-query-digest</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /var/log/mysql/slow-query.log</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="索引常见问题汇总" tabindex="-1"><a class="header-anchor" href="#索引常见问题汇总"><span>索引常见问题汇总</span></a></h2><h3 id="使用自增主键" tabindex="-1"><a class="header-anchor" href="#使用自增主键"><span>使用自增主键</span></a></h3><p>数据库为什么定义主键，并且在MySQL中使用推荐使用主键自增的策略？</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">为什么要自定义主键：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">因为假如不自定义主键，那么在InnoDB中，也会维护一个隐藏的列来当做主键，这样就丢失了主键索引树的性能。</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">为什么要使用主键自增的策略呢？</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">因为在插入的过程中，需要经过 </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`分类、提取\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (树的旋转) 等步骤，如果使用主键自增的策略，那么永远只会影响到索引树右边的结构，这样对整个B+树的结构影响是有限的，可以提高插入的效率</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="索引越多越好" tabindex="-1"><a class="header-anchor" href="#索引越多越好"><span>索引越多越好？</span></a></h3><p>索引性能这么好，是不是一个表建立的索引越多越好？</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">不是。一个表中的索引建立多了会影响增删改的性能。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">在企业中，对于单表来说，建立几个索引是合适的呢？不同的企业可能有不同的规范，一般默认不超过五个。即默认声明的索引列不超过五列。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">. innodb 默认页大小</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">. 非聚集索引中、非唯一列的 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 只包含当前列信息吗？ </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">根据 </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`show index from table_name;\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 的查询结果来看确实如此，那这个索引列有多个重复值时，是如何存储的呢？</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">我原本的猜测是叶子结点存储了多个相关的主键信息</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">但有的书中有这样的描述：</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    对于二级非唯一索引而言，因为只有索引列本身再加上主键列才能保证索引记录是唯一的，</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    所以这二者合起来才能构成我们所说的“键”，而“值”就为空了，</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    也就是说，二级非唯一索引中，在记录构成方面，非叶子节点只是比叶子节点多了一个PageNo指针信息。</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">也就是说 主键 + 这个索引列 一起构成了 索引树中的 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ？....</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">. innodb中为什么要采用 聚集索引 ，这样导致回表时的性能消耗（虽然能通过联合索引避免回表、但这样做本身也需要权衡相关查询语句的使用频率和索引带来影响）和MyISAM中（单独存储数据）必然进行一次IO的消耗相比，差距大吗？</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">有相关解释是说MyISAM中的这种方式必然会进行一次IO, 是这样吗？</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">复杂点的情形下，当非聚集索引命中多条记录时：</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	Innodb：可能导致回表，会根据主键进行多次聚集索引查询</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">	MyISAM: 多次的随机IO?</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">innodb这样的策略是在 </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`可能导致回表\`</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> 和 </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">\`必然进行IO 之中的选择吗？</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://image.ventix.top/java/image-20220326090301653.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://image.ventix.top/java/image-20220326090335787.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://image.ventix.top/java/image-20220326090348362.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>`,17))])}const m=k(A,[["render",c],["__file","mysql-index.html.vue"]]),v=JSON.parse('{"path":"/java/database/db/mysql-index.html","title":"索引及优化","lang":"en-US","frontmatter":{"order":20,"title":"索引及优化","description":"SQL调优理论基础 索引数据结构 数据库索引是提高数据库查询性能的关键技术之一。索引类似于书籍的目录，通过索引可以快速定位到所需的数据，而不需要扫描整个表。 数据库索引的优缺点 索引的优点 提高查询速度：通过索引，数据库引擎可以快速定位到所需的数据，而不需要扫描整个表。 提高排序和分组效率：索引可以加速排序和分组操作。 唯一性约束：唯一索引可以确保数据...","head":[["meta",{"property":"og:url","content":"https://x.app/java/database/db/mysql-index.html"}],["meta",{"property":"og:site_name","content":"doc"}],["meta",{"property":"og:title","content":"索引及优化"}],["meta",{"property":"og:description","content":"SQL调优理论基础 索引数据结构 数据库索引是提高数据库查询性能的关键技术之一。索引类似于书籍的目录，通过索引可以快速定位到所需的数据，而不需要扫描整个表。 数据库索引的优缺点 索引的优点 提高查询速度：通过索引，数据库引擎可以快速定位到所需的数据，而不需要扫描整个表。 提高排序和分组效率：索引可以加速排序和分组操作。 唯一性约束：唯一索引可以确保数据..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://image.ventix.top/java/image-20220324204029868.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-01-19T15:33:28.000Z"}],["meta",{"property":"article:author","content":"ventixy"}],["meta",{"property":"article:modified_time","content":"2025-01-19T15:33:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"索引及优化\\",\\"image\\":[\\"https://image.ventix.top/java/image-20220324204029868.png\\",\\"https://image.ventix.top/java/image-20220324205314504.png\\",\\"https://image.ventix.top/java/image-20220324204347069.png\\",\\"https://image.ventix.top/java/image-20220324204721606.png\\",\\"https://image.ventix.top/java/image-20220324204910192.png\\",\\"https://image.ventix.top/java/image-20220325121029629.png\\",\\"https://image.ventix.top/java/image-20220325121053355.png\\",\\"https://image.ventix.top/java/image-20220326090301653.png\\",\\"https://image.ventix.top/java/image-20220326090335787.png\\",\\"https://image.ventix.top/java/image-20220326090348362.png\\"],\\"dateModified\\":\\"2025-01-19T15:33:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ventixy\\",\\"url\\":\\"https://www.ventix.top\\"}]}"]]},"headers":[{"level":2,"title":"SQL调优理论基础","slug":"sql调优理论基础","link":"#sql调优理论基础","children":[{"level":3,"title":"索引数据结构","slug":"索引数据结构","link":"#索引数据结构","children":[]},{"level":3,"title":"B+树索引","slug":"b-树索引","link":"#b-树索引","children":[]},{"level":3,"title":"回表/覆盖索引","slug":"回表-覆盖索引","link":"#回表-覆盖索引","children":[]},{"level":3,"title":"最左前缀原则","slug":"最左前缀原则","link":"#最左前缀原则","children":[]},{"level":3,"title":"数据库查询优化","slug":"数据库查询优化","link":"#数据库查询优化","children":[]}]},{"level":2,"title":"MySQL数据库调优","slug":"mysql数据库调优","link":"#mysql数据库调优","children":[{"level":3,"title":"索引及文件位置","slug":"索引及文件位置","link":"#索引及文件位置","children":[]},{"level":3,"title":"MySQL存储引擎","slug":"mysql存储引擎","link":"#mysql存储引擎","children":[]},{"level":3,"title":"索引的分类和创建","slug":"索引的分类和创建","link":"#索引的分类和创建","children":[]},{"level":3,"title":"使用EXPLAIN","slug":"使用explain","link":"#使用explain","children":[]},{"level":3,"title":"开启慢查询日志","slug":"开启慢查询日志","link":"#开启慢查询日志","children":[]}]},{"level":2,"title":"索引常见问题汇总","slug":"索引常见问题汇总","link":"#索引常见问题汇总","children":[{"level":3,"title":"使用自增主键","slug":"使用自增主键","link":"#使用自增主键","children":[]},{"level":3,"title":"索引越多越好？","slug":"索引越多越好","link":"#索引越多越好","children":[]}]}],"git":{"createdTime":1736522381000,"updatedTime":1737300808000,"contributors":[{"name":"drizzle","email":"msdrizzle@outlook.com","commits":1}]},"readingTime":{"minutes":23.06,"words":6917},"filePathRelative":"java/database/db/mysql-index.md","localizedDate":"January 10, 2025","excerpt":"<h2>SQL调优理论基础</h2>\\n<h3>索引数据结构</h3>\\n<p>数据库索引是提高数据库查询性能的关键技术之一。索引类似于书籍的目录，通过索引可以快速定位到所需的数据，而不需要扫描整个表。</p>\\n<details class=\\"hint-container details\\"><summary>数据库索引的优缺点</summary>\\n<h4>索引的优点</h4>\\n<ol>\\n<li><strong>提高查询速度</strong>：通过索引，数据库引擎可以快速定位到所需的数据，而不需要扫描整个表。</li>\\n<li><strong>提高排序和分组效率</strong>：索引可以加速排序和分组操作。</li>\\n<li><strong>唯一性约束</strong>：唯一索引可以确保数据的唯一性，防止重复数据的插入。</li>\\n</ol>\\n<h4>索引的缺点</h4>\\n<ol>\\n<li><strong>增加存储空间</strong>：索引需要额外的存储空间，尤其是大型表和多列索引。</li>\\n<li><strong>降低写操作性能</strong>：插入、更新和删除操作需要维护索引，增加了这些操作的开销。</li>\\n<li><strong>复杂性</strong>：过多的索引会使数据库设计和维护变得复杂。</li>\\n</ol>\\n</details>","autoDesc":true}');export{m as comp,v as data};
