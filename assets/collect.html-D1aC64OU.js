import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,b as t,a as h,e as s,d as r,w as l,r as o,o as p}from"./app-C7Xqo3QE.js";const d={};function c(g,a){const i=o("RouteLink");return p(),n("div",null,[a[2]||(a[2]=t(`<h2 id="java集合体系" tabindex="-1"><a class="header-anchor" href="#java集合体系"><span>Java集合体系</span></a></h2><figure><img src="https://s2.loli.net/2022/01/10/pnf7euRo8Y6LQlq.png" alt="Java集合体系" tabindex="0" loading="lazy"><figcaption>Java集合体系</figcaption></figure><h4 id="java-中有哪些集合类-请简单介绍" tabindex="-1"><a class="header-anchor" href="#java-中有哪些集合类-请简单介绍"><span>Java 中有哪些集合类？请简单介绍</span></a></h4><ul><li><strong>List</strong>：有序集合，允许重复元素，主要实现类有 <code>ArrayList</code>、<code>LinkedList</code>。</li><li><strong>Set</strong>：无序集合，不允许重复元素，主要实现类有 <code>HashSet</code>、<code>TreeSet</code>、<code>LinkedHashSet</code>。</li><li><strong>Map</strong>：键值对集合，键唯一，主要实现类有 <code>HashMap</code>、<code>Hashtable</code>、<code>TreeMap</code>、<code>LinkedHashMap</code>、<code>ConcurrentHashMap</code>。</li></ul><h3 id="数组和链表" tabindex="-1"><a class="header-anchor" href="#数组和链表"><span>数组和链表</span></a></h3><h4 id="数组和链表在-java-中的区别是什么" tabindex="-1"><a class="header-anchor" href="#数组和链表在-java-中的区别是什么"><span>数组和链表在 Java 中的区别是什么？</span></a></h4><ul><li><strong>数组</strong>：连续的内存空间，支持随机访问，插入和删除效率低。</li><li><strong>链表</strong>：不连续的内存空间，插入和删除效率高，不支持随机访问。</li></ul><h4 id="java-中的-list-接口有哪些实现类" tabindex="-1"><a class="header-anchor" href="#java-中的-list-接口有哪些实现类"><span>Java 中的 List 接口有哪些实现类？</span></a></h4><ul><li><strong>ArrayList</strong>：基于动态数组实现，支持随机访问，插入和删除效率低。</li><li><strong>LinkedList</strong>：基于双向链表实现，插入和删除效率高，不支持随机访问。</li><li><strong>Vector</strong>：线程安全的 <code>ArrayList</code>，性能较低。</li><li><strong>CopyOnWriteArrayList</strong>：线程安全的 <code>ArrayList</code>，写操作时复制整个数组。</li></ul><h4 id="java-中-arraylist-和-linkedlist-有什么区别" tabindex="-1"><a class="header-anchor" href="#java-中-arraylist-和-linkedlist-有什么区别"><span>Java 中 ArrayList 和 LinkedList 有什么区别？</span></a></h4><ul><li><strong>ArrayList</strong>：基于动态数组，支持随机访问，插入和删除效率低。</li><li><strong>LinkedList</strong>：基于双向链表，插入和删除效率高，不支持随机访问。</li></ul><h4 id="java-arraylist-的扩容机制是什么" tabindex="-1"><a class="header-anchor" href="#java-arraylist-的扩容机制是什么"><span>Java ArrayList 的扩容机制是什么？</span></a></h4><ul><li><strong>扩容机制</strong>：当数组容量不足时，创建一个新的数组，容量为原数组的 1.5 倍，然后将原数组的元素复制到新数组中。</li></ul><h3 id="栈和队列" tabindex="-1"><a class="header-anchor" href="#栈和队列"><span>栈和队列</span></a></h3><h4 id="栈和队列在-java-中的区别是什么" tabindex="-1"><a class="header-anchor" href="#栈和队列在-java-中的区别是什么"><span>栈和队列在 Java 中的区别是什么？</span></a></h4><ul><li><strong>栈（Stack）</strong>：后进先出（LIFO），Stack是vector一个子类，主要操作有 <code>push</code>（入栈）、<code>pop</code>（出栈）和 <code>peek</code>（查看栈顶元素）。</li><li><strong>队列（Queue）</strong>：先进先出（FIFO），主要操作有 <code>offer</code>（入队）、<code>poll</code>（出队）和 <code>peek</code>（查看队首元素）。</li></ul><h3 id="线程安全集合" tabindex="-1"><a class="header-anchor" href="#线程安全集合"><span>线程安全集合</span></a></h3><h4 id="java-的-copyonwritearraylist-和-collections-synchronizedlist-有什么区别-分别有什么优缺点" tabindex="-1"><a class="header-anchor" href="#java-的-copyonwritearraylist-和-collections-synchronizedlist-有什么区别-分别有什么优缺点"><span>Java 的 CopyOnWriteArrayList 和 Collections.synchronizedList 有什么区别？分别有什么优缺点？</span></a></h4><ul><li><strong>CopyOnWriteArrayList</strong>： <ul><li><strong>优点</strong>：读操作不加锁，性能高。</li><li><strong>缺点</strong>：写操作需要复制整个数组，内存开销大。</li></ul></li><li><strong>Collections.synchronizedList</strong>： <ul><li><strong>优点</strong>：使用全局锁，实现简单。</li><li><strong>缺点</strong>：读写操作都需要加锁，性能较低。</li></ul></li></ul><h2 id="hashmap原理" tabindex="-1"><a class="header-anchor" href="#hashmap原理"><span>HashMap原理</span></a></h2><p>底层数据结构：数组 + 链表 + 红黑树 （jdk1.8之前没有红黑树结构，只是简单的 数组 + 链表 ）</p><h4 id="使用-hashmap-时-有哪些提升性能的技巧" tabindex="-1"><a class="header-anchor" href="#使用-hashmap-时-有哪些提升性能的技巧"><span>使用 HashMap 时，有哪些提升性能的技巧？</span></a></h4><ul><li><strong>初始容量</strong>：合理设置初始容量，避免频繁扩容。</li><li><strong>负载因子</strong>：适当调整负载因子，平衡时间和空间开销。</li><li><strong>避免哈希冲突</strong>：使用高质量的哈希函数，减少哈希冲突。</li></ul><h3 id="扩容机制" tabindex="-1"><a class="header-anchor" href="#扩容机制"><span>扩容机制</span></a></h3><h4 id="java-中-hashmap-的扩容机制是怎样的" tabindex="-1"><a class="header-anchor" href="#java-中-hashmap-的扩容机制是怎样的"><span>Java 中 HashMap 的扩容机制是怎样的？</span></a></h4><ul><li><strong>扩容机制</strong>：当元素数量超过阈值（容量 * 负载因子）时，创建一个新的数组，容量为原数组的 2 倍，然后将原数组的元素重新哈希到新数组中。</li></ul><h4 id="为什么-hashmap-在-java-中扩容时采用-2-的-n-次方倍" tabindex="-1"><a class="header-anchor" href="#为什么-hashmap-在-java-中扩容时采用-2-的-n-次方倍"><span>为什么 HashMap 在 Java 中扩容时采用 2 的 n 次方倍？</span></a></h4><ul><li><strong>2 的 n 次方</strong>：确保哈希值与数组长度的模运算结果均匀分布，减少哈希冲突。</li></ul><h3 id="默认负载因子" tabindex="-1"><a class="header-anchor" href="#默认负载因子"><span>默认负载因子</span></a></h3><h4 id="为什么-java-中-hashmap-的默认负载因子是-0-75" tabindex="-1"><a class="header-anchor" href="#为什么-java-中-hashmap-的默认负载因子是-0-75"><span>为什么 Java 中 HashMap 的默认负载因子是 0.75？</span></a></h4><ul><li><strong>负载因子</strong>：0.75 是一个经验值，平衡了时间和空间开销，既能保证较高的空间利用率，又能减少哈希冲突。</li></ul><h3 id="哈希碰撞" tabindex="-1"><a class="header-anchor" href="#哈希碰撞"><span>哈希碰撞</span></a></h3><h4 id="什么是-hash-碰撞-怎么解决哈希碰撞" tabindex="-1"><a class="header-anchor" href="#什么是-hash-碰撞-怎么解决哈希碰撞"><span>什么是 Hash 碰撞？怎么解决哈希碰撞？</span></a></h4><ul><li><strong>哈希碰撞</strong>：多个键计算出相同的哈希值。</li><li><strong>解决方法</strong>：使用链地址法（链表）或开放地址法（线性探测、二次探测、双散列）。</li></ul><h4 id="为什么-jdk-1-8-对-hashmap-进行了红黑树的改动" tabindex="-1"><a class="header-anchor" href="#为什么-jdk-1-8-对-hashmap-进行了红黑树的改动"><span>为什么 JDK 1.8 对 HashMap 进行了红黑树的改动？</span></a></h4><ul><li><strong>红黑树</strong>：当链表长度超过 8 且数组长度大于等于 64 时，将链表转换为红黑树，提高查找效率。</li></ul><h4 id="jdk-1-8-对-hashmap-除了红黑树还进行了哪些改动" tabindex="-1"><a class="header-anchor" href="#jdk-1-8-对-hashmap-除了红黑树还进行了哪些改动"><span>JDK 1.8 对 HashMap 除了红黑树还进行了哪些改动？</span></a></h4><ul><li><strong>CAS 操作</strong>：使用 CAS 操作提高并发性能。</li><li><strong>树化阈值</strong>：引入了树化阈值和取消树化的阈值。</li><li><strong>优化初始化</strong>：延迟初始化，减少不必要的初始化开销。</li></ul><h3 id="hashtable" tabindex="-1"><a class="header-anchor" href="#hashtable"><span>Hashtable</span></a></h3><p>Hashtable是数组+链表 (没有红黑树; jdk1.8之前的HashMap一样)</p><h4 id="java-中的-hashmap-和-hashtable-有什么区别" tabindex="-1"><a class="header-anchor" href="#java-中的-hashmap-和-hashtable-有什么区别"><span>Java 中的 HashMap 和 Hashtable 有什么区别？</span></a></h4><ul><li><strong>HashMap</strong>：非线程安全，允许键和值为 <code>null</code>，性能较高。</li><li><strong>Hashtable</strong>：线程安全，不允许键和值为 <code>null</code>，性能较低。</li></ul><h4 id="concurrenthashmap-和-hashtable-的区别是什么" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-和-hashtable-的区别是什么"><span>ConcurrentHashMap 和 Hashtable 的区别是什么？</span></a></h4><ul><li><strong>ConcurrentHashMap</strong>：线程安全，使用分段锁（JDK 1.8 使用 CAS 和 synchronized）实现，性能较高。</li><li><strong>Hashtable</strong>：线程安全，使用全局锁实现，性能较低。</li></ul><h4 id="java-中的-hashset-和-hashmap-有什么区别" tabindex="-1"><a class="header-anchor" href="#java-中的-hashset-和-hashmap-有什么区别"><span>Java 中的 HashSet 和 HashMap 有什么区别？</span></a></h4><ul><li><strong>HashSet</strong>：基于 <code>HashMap</code> 实现，不允许重复元素，不保证顺序。</li><li><strong>HashMap</strong>：键值对集合，键唯一，允许值为 <code>null</code>。</li></ul><h3 id="concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap"><span>ConcurrentHashMap</span></a></h3><h4 id="java-中-concurrenthashmap-1-7-和-1-8-之间有哪些区别" tabindex="-1"><a class="header-anchor" href="#java-中-concurrenthashmap-1-7-和-1-8-之间有哪些区别"><span>Java 中 ConcurrentHashMap 1.7 和 1.8 之间有哪些区别？</span></a></h4><ul><li><strong>1.7</strong>：使用分段锁（Segment）实现，每个 Segment 管理一部分桶。</li><li><strong>1.8</strong>：使用 CAS 操作和 synchronized 实现，提高了并发性能，引入了红黑树结构。</li></ul><h4 id="java-中-concurrenthashmap-的-get-方法是否需要加锁" tabindex="-1"><a class="header-anchor" href="#java-中-concurrenthashmap-的-get-方法是否需要加锁"><span>Java 中 ConcurrentHashMap 的 get 方法是否需要加锁？</span></a></h4><ul><li><strong>不需要</strong>：<code>get</code> 方法是非阻塞的，不涉及修改操作，不需要加锁。</li></ul><h4 id="为什么-java-的-concurrenthashmap-不支持-key-或-value-为-null" tabindex="-1"><a class="header-anchor" href="#为什么-java-的-concurrenthashmap-不支持-key-或-value-为-null"><span>为什么 Java 的 ConcurrentHashMap 不支持 key 或 value 为 null？</span></a></h4><ul><li><strong>设计原因</strong>：<code>null</code> 值会导致查找和删除操作复杂化，影响性能和一致性。</li></ul><h3 id="其他map" tabindex="-1"><a class="header-anchor" href="#其他map"><span>其他Map</span></a></h3><h4 id="java-中的-linkedhashmap-是什么" tabindex="-1"><a class="header-anchor" href="#java-中的-linkedhashmap-是什么"><span>Java 中的 LinkedHashMap 是什么？</span></a></h4><ul><li><strong>LinkedHashMap</strong>：基于 <code>HashMap</code> 实现，维护插入顺序或访问顺序。</li></ul><h4 id="java-中的-treemap-是什么" tabindex="-1"><a class="header-anchor" href="#java-中的-treemap-是什么"><span>Java 中的 TreeMap 是什么？</span></a></h4><ul><li><strong>TreeMap</strong>：基于红黑树实现，按键的自然顺序或自定义比较器排序。</li></ul><h4 id="java-中的-identityhashmap-是什么" tabindex="-1"><a class="header-anchor" href="#java-中的-identityhashmap-是什么"><span>Java 中的 IdentityHashMap 是什么？</span></a></h4><ul><li><strong>IdentityHashMap</strong>：基于对象的引用地址而不是 <code>equals</code> 方法比较键，适用于需要基于引用比较的场景。</li></ul><h4 id="java-中的-weakhashmap-是什么" tabindex="-1"><a class="header-anchor" href="#java-中的-weakhashmap-是什么"><span>Java 中的 WeakHashMap 是什么？</span></a></h4><ul><li><strong>WeakHashMap</strong>：基于弱引用实现，键可以被垃圾回收，适用于缓存场景。</li></ul><h2 id="foreach-iterator" tabindex="-1"><a class="header-anchor" href="#foreach-iterator"><span>foreach/Iterator</span></a></h2><h4 id="你遇到过-concurrentmodificationexception-错误吗-它是如何产生的" tabindex="-1"><a class="header-anchor" href="#你遇到过-concurrentmodificationexception-错误吗-它是如何产生的"><span>你遇到过 ConcurrentModificationException 错误吗？它是如何产生的？</span></a></h4><ul><li><strong>ConcurrentModificationException</strong>：在遍历集合时，集合被其他线程修改导致。</li><li><strong>产生原因</strong>：使用迭代器遍历时，集合被修改（如添加、删除元素）。</li></ul><p>Java 中 for 循环与 foreach 循环的区别是什么？</p><div class="hint-container info"><p class="hint-container-title">for循环和foreach的区别</p><h4 id="foreach" tabindex="-1"><a class="header-anchor" href="#foreach"><span>foreach</span></a></h4><p>foreach是 java5 引入的一种简化的循环结构，常用于遍历 <strong>数组</strong> 或 <strong>实现了Iterable接口的集合</strong></p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> fruit </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> fruits) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(fruit);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>foreach虽然简洁易用，但不提供对当前索引的访问</li><li>遍历过程中不能修改集合的结构（添加或删除集合元素），否则会抛出并发修改异常<code>ConcurrentModificationException</code></li></ul><h4 id="for循环" tabindex="-1"><a class="header-anchor" href="#for循环"><span>for循环</span></a></h4><p>for循环则更加灵活，可以控制循环的初始值，终止条件和步进方式。适用于需要通过索引访问元素，或在循环中添加/删除集合中的元素</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">[] numbers </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 5</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> numbers</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(numbers[i]);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><p>什么是 Java 中的迭代器（Iterator）？</p><div class="hint-container warning"><p class="hint-container-title">Iterator迭代器</p><p>Iterator是Java集合框架中用于遍历集合元素的接口，迭代器是的遍历不同类型的集合更加简洁，统一，提升了代码的可读性。在遍历过程中还可以添加或删除元素。比如：<code>iterator.remove()</code></p><ul><li><p>Iterator 迭代器采用的是 快速失败（fail-fast）机制，一旦使用非Iterator的方法或其他线程修改了集合，就会导致集合的<code>modCount</code>和 Iterator的<code>expectedModCount</code>不相等，将引发<code>ConcurrentModificationException</code>异常</p></li><li><p>对集合使用foreach循环，本质上也是Iterator，同样不能随意修改。对数组使用foreach则会被编译成为传统的for循环</p></li></ul><p>List专门提供了ListIterator方法，其返回值是一个Iterator的子接口，最明显的特点就是支持双向遍历(<code>hasPrevious</code>和<code>previous</code>)</p></div>`,69)),h("p",null,[a[1]||(a[1]=s("关于集合 迭代器，及其与Foreach的关系参照：")),r(i,{to:"/java/syntax/base/collection.html#_1-iterator"},{default:l(()=>a[0]||(a[0]=[s("Iterator")])),_:1})])])}const v=e(d,[["render",c],["__file","collect.html.vue"]]),m=JSON.parse('{"path":"/interview/java/collect.html","title":"Java集合","lang":"en-US","frontmatter":{"order":10,"title":"Java集合","description":"Java集合体系 Java集合体系Java集合体系 Java 中有哪些集合类？请简单介绍 List：有序集合，允许重复元素，主要实现类有 ArrayList、LinkedList。 Set：无序集合，不允许重复元素，主要实现类有 HashSet、TreeSet、LinkedHashSet。 Map：键值对集合，键唯一，主要实现类有 HashMap、Ha...","head":[["meta",{"property":"og:url","content":"https://x.app/interview/java/collect.html"}],["meta",{"property":"og:site_name","content":"doc"}],["meta",{"property":"og:title","content":"Java集合"}],["meta",{"property":"og:description","content":"Java集合体系 Java集合体系Java集合体系 Java 中有哪些集合类？请简单介绍 List：有序集合，允许重复元素，主要实现类有 ArrayList、LinkedList。 Set：无序集合，不允许重复元素，主要实现类有 HashSet、TreeSet、LinkedHashSet。 Map：键值对集合，键唯一，主要实现类有 HashMap、Ha..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://s2.loli.net/2022/01/10/pnf7euRo8Y6LQlq.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-01-10T15:19:41.000Z"}],["meta",{"property":"article:author","content":"ventixy"}],["meta",{"property":"article:modified_time","content":"2025-01-10T15:19:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java集合\\",\\"image\\":[\\"https://s2.loli.net/2022/01/10/pnf7euRo8Y6LQlq.png\\"],\\"dateModified\\":\\"2025-01-10T15:19:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ventixy\\",\\"url\\":\\"https://www.ventix.top\\"}]}"]]},"headers":[{"level":2,"title":"Java集合体系","slug":"java集合体系","link":"#java集合体系","children":[{"level":3,"title":"数组和链表","slug":"数组和链表","link":"#数组和链表","children":[]},{"level":3,"title":"栈和队列","slug":"栈和队列","link":"#栈和队列","children":[]},{"level":3,"title":"线程安全集合","slug":"线程安全集合","link":"#线程安全集合","children":[]}]},{"level":2,"title":"HashMap原理","slug":"hashmap原理","link":"#hashmap原理","children":[{"level":3,"title":"扩容机制","slug":"扩容机制","link":"#扩容机制","children":[]},{"level":3,"title":"默认负载因子","slug":"默认负载因子","link":"#默认负载因子","children":[]},{"level":3,"title":"哈希碰撞","slug":"哈希碰撞","link":"#哈希碰撞","children":[]},{"level":3,"title":"Hashtable","slug":"hashtable","link":"#hashtable","children":[]},{"level":3,"title":"ConcurrentHashMap","slug":"concurrenthashmap","link":"#concurrenthashmap","children":[]},{"level":3,"title":"其他Map","slug":"其他map","link":"#其他map","children":[]}]},{"level":2,"title":"foreach/Iterator","slug":"foreach-iterator","link":"#foreach-iterator","children":[]}],"git":{"createdTime":1736522381000,"updatedTime":1736522381000,"contributors":[{"name":"drizzle","email":"msdrizzle@outlook.com","commits":1}]},"readingTime":{"minutes":6.32,"words":1897},"filePathRelative":"interview/java/collect.md","localizedDate":"January 10, 2025","excerpt":"<h2>Java集合体系</h2>\\n<figure><img src=\\"https://s2.loli.net/2022/01/10/pnf7euRo8Y6LQlq.png\\" alt=\\"Java集合体系\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>Java集合体系</figcaption></figure>\\n<h4>Java 中有哪些集合类？请简单介绍</h4>\\n<ul>\\n<li><strong>List</strong>：有序集合，允许重复元素，主要实现类有 <code>ArrayList</code>、<code>LinkedList</code>。</li>\\n<li><strong>Set</strong>：无序集合，不允许重复元素，主要实现类有 <code>HashSet</code>、<code>TreeSet</code>、<code>LinkedHashSet</code>。</li>\\n<li><strong>Map</strong>：键值对集合，键唯一，主要实现类有 <code>HashMap</code>、<code>Hashtable</code>、<code>TreeMap</code>、<code>LinkedHashMap</code>、<code>ConcurrentHashMap</code>。</li>\\n</ul>","autoDesc":true}');export{v as comp,m as data};
