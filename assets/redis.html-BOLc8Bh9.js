import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as g,a as i,b as e,d as k,e as s,w as a,r,o}from"./app-Ccqv2WFz.js";const u={};function A(y,l){const d=r("RouteLink"),h=r("Tabs");return o(),g("div",null,[l[25]||(l[25]=i("h2",{id:"redis缓存基础",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#redis缓存基础"},[i("span",null,"Redis缓存基础")])],-1)),l[26]||(l[26]=i("p",null,"Redis之所以能够实现高性能，主要得益于其单线程模型、内存操作、IO多路复用机制",-1)),i("ul",null,[l[3]||(l[3]=i("li",null,[i("p",null,"单线程：由于所有命令都在同一个线程中顺序执行，因此不需要复杂的锁机制来保护共享资源，避免了多线程环境下的竞态条件和死锁问题。减少上下文切换开销。")],-1)),l[4]||(l[4]=i("li",null,[i("p",null,"基于内存操作：RAM访问时间远低于磁盘I/O。")],-1)),i("li",null,[i("p",null,[l[1]||(l[1]=s("非阻塞")),e(d,{to:"/java/core/io/nio.html#i-o%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86"},{default:a(()=>l[0]||(l[0]=[s("IO多路复用")])),_:1}),l[2]||(l[2]=s("：Redis采用了基于epoll的事件驱动架构，可以在不阻塞主线程的情况下同时监听多个客户端连接的状态变化。通过异步读取和写入网络套接字，Redis可以最大限度地利用可用带宽，而不必等待每一个单独的操作完成。"))])])]),l[27]||(l[27]=i("h3",{id:"常用数据类型",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#常用数据类型"},[i("span",null,"常用数据类型")])],-1)),l[28]||(l[28]=i("p",null,"Redis常见数据类型：字符串，哈希，列表，集合，有序集合",-1)),e(h,{id:"29",data:[{id:"String"},{id:"Hash"},{id:"List"},{id:"Set"},{id:"ZSet"}],active:0},{title0:a(({value:n,isActive:t})=>l[5]||(l[5]=[s("String")])),title1:a(({value:n,isActive:t})=>l[6]||(l[6]=[s("Hash")])),title2:a(({value:n,isActive:t})=>l[7]||(l[7]=[s("List")])),title3:a(({value:n,isActive:t})=>l[8]||(l[8]=[s("Set")])),title4:a(({value:n,isActive:t})=>l[9]||(l[9]=[s("ZSet")])),tab0:a(({value:n,isActive:t})=>l[10]||(l[10]=[i("p",null,[s("String（字符串）不仅可以存储字符串, 还可以存储整数或浮点数。适用于缓存"),i("strong",null,"热点数据"),s("，实现各种计数器功能（如网站访问统计、点赞次数等）")],-1),i("div",{class:"language-bash line-numbers-mode","data-highlighter":"shiki","data-ext":"bash","data-title":"bash",style:{"--shiki-light":"#383A42","--shiki-dark":"#abb2bf","--shiki-light-bg":"#FAFAFA","--shiki-dark-bg":"#282c34"}},[i("pre",{class:"shiki shiki-themes one-light one-dark-pro vp-code"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 设置指定键的值，并可选地设置过期时间（秒或毫秒） |  获取指定键的值")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"SET"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," mykey"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},' "Hello"'),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," EX"),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}}," 10"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," NX")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"GET"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," mykey")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 将键所存储的数值加一/减一。如果键不存在，则认为它的值是 0")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"INCR"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," counter")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"DECR"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," counter")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 将键所存储的数值加上/减去指定增量。同样，若键不存在则视为 0")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"INCRBY"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," score"),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}}," 5")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"DECRBY"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," score"),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}}," 2")])])]),i("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"})])],-1),i("ul",null,[i("li",null,[i("p",null,"底层实现: SDS (Simple Dynamic String) Redis 使用自己实现的简单动态字符串结构来表示 String 类型的数据。")]),i("li",null,[i("p",null,"对于较短的字符串（小于等于39个字节），Redis 采用 embstr 编码, 对于较长的字符串，则使用普通的 raw 编码。")])],-1),i("p",null,"String 实际上可以容纳任意二进制数据，可达 512MB。",-1)])),tab1:a(({value:n,isActive:t})=>l[11]||(l[11]=[i("p",null,[s("Hash(哈希) 是一种键值对集合的数据结构，非常适合"),i("mark",null,"存储对象"),s("（可存取对象中的属性，并且支持原子性操作），如"),i("strong",null,"购物车"),s("对象")],-1),i("ul",null,[i("li",null,[i("p",null,"压缩列表（ziplist）：为了节省内存空间，当 Hash 中的元素数量较少且单个元素大小较小时，Redis 会使用压缩列表作为底层实现。(在 Redis 7.0 及以上版本中，ziplist 被 listpack 所取代)")]),i("li",null,[i("p",null,"哈希表（hashtable）：随着 Hash 中元素数量的增长或单个元素变大，Redis 会自动将压缩列表转换为更高效的哈希表结构。")])],-1),i("div",{class:"language-bash line-numbers-mode","data-highlighter":"shiki","data-ext":"bash","data-title":"bash",style:{"--shiki-light":"#383A42","--shiki-dark":"#abb2bf","--shiki-light-bg":"#FAFAFA","--shiki-dark-bg":"#282c34"}},[i("pre",{class:"shiki shiki-themes one-light one-dark-pro vp-code"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 用户 user123 添加了两个 item456 商品")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"HSET"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," cart:user123"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," item456"),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}}," 2")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 查看用户 user123 的购物车物品")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"HGETALL"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," cart:user123")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 查询 user123 的 item456 数量")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"HGET"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," cart:user123"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," item456")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 用户 user123 移除了一个 item456 商品（注意确保不会出现负数）")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"HINCRBY"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," cart:user123"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," item456"),i("span",{style:{"--shiki-light":"#986801","--shiki-dark":"#D19A66"}}," -1")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 完全删除某商品")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"HDEL"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," cart:userid"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," itemid")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 一次性清除所有商品")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"DEL"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," cart:userid")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 统计购物车中商品种类数")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"HLEN"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," cart:userid")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 分别统计购物车中每种商品的数量")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"HVALS"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," cart:userid")])])]),i("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"})])],-1),i("p",null,"哈希表是一种通过哈希函数将键映射到特定位置的数据结构，使得查找、插入和删除操作的时间复杂度接近 O(1)。",-1)])),tab2:a(({value:n,isActive:t})=>l[12]||(l[12]=[i("p",null,[s("Redis 中的 List 是一种双向链表（linked list）数据结构，它可以在列表的头部和尾部高效地添加或移除元素。可利用List实现分布式的 "),i("strong",null,"栈和队列"),s("：")],-1),i("p",null,"栈（Stack）是一种后进先出（LIFO, Last In First Out）的数据结构",-1),i("div",{class:"language-bash line-numbers-mode","data-highlighter":"shiki","data-ext":"bash","data-title":"bash",style:{"--shiki-light":"#383A42","--shiki-dark":"#abb2bf","--shiki-light-bg":"#FAFAFA","--shiki-dark-bg":"#282c34"}},[i("pre",{class:"shiki shiki-themes one-light one-dark-pro vp-code"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"LPUSH"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," key"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," value"),i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"    # 将一个值插入到列表的头部（左端）")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"LPOP"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," key"),i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"           # 移除并返回列表的第一个元素（左端的元素）")])])]),i("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[i("div",{class:"line-number"}),i("div",{class:"line-number"})])],-1),i("p",null,"队列（Queue）是一种先进先出（FIFO, First In First Out）的数据结构",-1),i("div",{class:"language-bash line-numbers-mode","data-highlighter":"shiki","data-ext":"bash","data-title":"bash",style:{"--shiki-light":"#383A42","--shiki-dark":"#abb2bf","--shiki-light-bg":"#FAFAFA","--shiki-dark-bg":"#282c34"}},[i("pre",{class:"shiki shiki-themes one-light one-dark-pro vp-code"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"LPUSH"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," key"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," value"),i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"    # 将一个值插入到列表的尾部（右端）")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"RPOP"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," key"),i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"           # 移除并返回列表的第一个元素（左端的元素）")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 阻塞队列 示例：")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"LPUSH"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," key"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," value")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"BRPOP"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," key"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}}," [key "),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},"...]"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," timeout"),i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"  # 列表为空则阻塞连接直到等待超时或元素入列")])])]),i("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"})])],-1),i("p",null,[i("strong",null,"其他应用场景"),s("：")],-1),i("ul",null,[i("li",null,[i("strong",null,"任务队列"),s("：可以用来管理待处理的任务，确保任务按照一定的顺序被执行。")]),i("li",null,[i("strong",null,"社交网络的消息流"),s("：例如 微博，可以通过 List 来保存用户发布的新鲜事。")]),i("li",null,[i("strong",null,"缓存最近/最频繁使用的数据"),s("：例如，可以维护一个最近浏览商品的列表。")])],-1)])),tab3:a(({value:n,isActive:t})=>l[13]||(l[13]=[i("p",null,"Set 是一种无序且不允许重复元素的数据结构，非常适合用于存储唯一性的数据集合。",-1),i("ul",null,[i("li",null,[i("p",null,"Set 支持高效的成员添加、删除和检查操作，并且能够执行交集、并集和差集等集合运算。")]),i("li",null,[i("p",null,[s("Set 的底层实现是基于哈希表（hash table），这使得其成员性检查、添加和移除操作的时间复杂度接近于 O(1)。"),i("em",null,[s("对于小集合，为了节省内存，当集合中元素的数量很少（默认 "),i("strong",null,"小于64"),s(" 个元素）且成员为整数时，Redis 使用一种叫做 "),i("mark",null,"intset（整数集合）"),s(" 的紧凑编码方式来表示集合")]),s("。")])])],-1),i("p",null,[s("应用场景: "),i("strong",null,"去重，点赞，关注模型，抽奖"),s("， 下为一个简单的抽奖示例：")],-1),i("div",{class:"language-bash line-numbers-mode","data-highlighter":"shiki","data-ext":"bash","data-title":"bash",style:{"--shiki-light":"#383A42","--shiki-dark":"#abb2bf","--shiki-light-bg":"#FAFAFA","--shiki-dark-bg":"#282c34"}},[i("pre",{class:"shiki shiki-themes one-light one-dark-pro vp-code"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 1. 初始化奖池")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"SADD"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," raffle_pool"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," participant1"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," participant2"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," participant3"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," ..."),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," participantN")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 2. (可选) 查看所有参与抽奖者")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"SMEMBERS"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," raffle_pool")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 3. 抽取幸运儿")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 方法一: 使用 SPOP 直接抽取并移除")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#E45649","--shiki-dark":"#E06C75"}},"winner"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#56B6C2"}},"="),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},"$("),i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"SPOP"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," raffle_pool"),i("span",{style:{"--shiki-light":"#383A42","--shiki-dark":"#ABB2BF"}},")")]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 方法二: 使用 SRANDMEMBER 和 SREM 组合")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# winner=$(SRANDMEMBER raffle_pool)    # 返回一个随机的参与者，但不移除它")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},'# SREM raffle_pool "$winner"           # 将指定的参与者从奖池中移除')]),s(`
`),i("span",{class:"line"}),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 4. 记录中奖结果")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"RPUSH"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," winners"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},' "'),i("span",{style:{"--shiki-light":"#E45649","--shiki-dark":"#E06C75"}},"$winner"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},'"'),i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"  # 使用 List 记录中奖者顺序")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"# 或者")]),s(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#4078F2","--shiki-dark":"#61AFEF"}},"SADD"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}}," winners_set"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},' "'),i("span",{style:{"--shiki-light":"#E45649","--shiki-dark":"#E06C75"}},"$winner"),i("span",{style:{"--shiki-light":"#50A14F","--shiki-dark":"#98C379"}},'"'),i("span",{style:{"--shiki-light":"#A0A1A7","--shiki-light-font-style":"italic","--shiki-dark":"#7F848E","--shiki-dark-font-style":"italic"}},"  # 使用 Set 确保唯一性")])])]),i("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"}),i("div",{class:"line-number"})])],-1)])),tab4:a(({value:n,isActive:t})=>l[14]||(l[14]=[i("p",null,"ZSet（Sorted Set，有序集合）每个成员关联一个分数（score），使其可以根据分数进行排序",-1),i("ul",null,[i("li",null,"成员数量较少时使用压缩列表（ziplist / listpack）以节省内存"),i("li",null,"当成员数量或大小超过一定阈值时，则采用跳跃表（skiplist）结合哈希表（hash table）来保证高效的操作和成员唯一性")],-1),i("p",null,[s("应用场景："),i("strong",null,"排行榜")],-1)])),_:1}),l[29]||(l[29]=k(`<p>在 Redis 中，<code>TYPE</code> 和 <code>OBJECT ENCODING</code> 提供了关于键的不同层次的信息:</p><ul><li><strong><code>TYPE</code></strong> 查询这个键代表的是什么类型的数据结构（如字符串、列表、集合等）</li><li><strong><code>OBJECT ENCODING</code></strong> 展示 Redis 内部是如何实际存储这些数据结构的（使用哪种编码方式）</li></ul><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">HSET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> user:1000</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> name</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Alice&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 查询该键的类型</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">TYPE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> user:1000</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                       # hash</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 查询 user:1000 的底层编码方式</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">OBJECT</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ENCODING</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> user:1000</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            # listpack</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="底层数据结构" tabindex="-1"><a class="header-anchor" href="#底层数据结构"><span>底层数据结构</span></a></h3><p>Redis内部使用了多种底层数据结构: 哈希表, 双向链表, 整数集合, 压缩列表, 跳表</p>`,5)),e(h,{id:"169",data:[{id:"哈希表"},{id:"双向链表"},{id:"整数集合"},{id:"压缩列表"},{id:"跳表"}],active:4},{title0:a(({value:n,isActive:t})=>l[15]||(l[15]=[s("哈希表")])),title1:a(({value:n,isActive:t})=>l[16]||(l[16]=[s("双向链表")])),title2:a(({value:n,isActive:t})=>l[17]||(l[17]=[s("整数集合")])),title3:a(({value:n,isActive:t})=>l[18]||(l[18]=[s("压缩列表")])),title4:a(({value:n,isActive:t})=>l[19]||(l[19]=[s("跳表")])),tab0:a(({value:n,isActive:t})=>l[20]||(l[20]=[i("h4",{id:"哈希表-hash-table",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#哈希表-hash-table"},[i("span",null,"哈希表（Hash Table）")])],-1),i("p",null,[s("主要用于实现 Redis 的 "),i("code",null,"Hash"),s(" 数据类型，以及 ZSet 和 Set 内部成员唯一性的保证。")],-1),i("ul",null,[i("li",null,"提供 O(1) 时间复杂度的插入、查找和删除操作。"),i("li",null,"使用拉链法解决哈希冲突问题。")],-1),i("p",null,"应用场景：适合需要快速查找、添加或移除元素的场景，如缓存、会话管理等。",-1)])),tab1:a(({value:n,isActive:t})=>l[21]||(l[21]=[i("h4",{id:"双向链表-doubly-linked-list-用于实现-redis-的-list-数据类型。",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#双向链表-doubly-linked-list-用于实现-redis-的-list-数据类型。"},[i("span",null,[s("双向链表（Doubly Linked List）: 用于实现 Redis 的 "),i("code",null,"List"),s(" 数据类型。")])])],-1),i("ul",null,[i("li",null,"每个节点包含指向前驱和后继节点的指针。"),i("li",null,"支持两端高效地插入和删除操作。")],-1),i("p",null,"应用场景：适用于队列、栈等先进先出（FIFO）或后进先出（LIFO）的数据处理模式。",-1)])),tab2:a(({value:n,isActive:t})=>l[22]||(l[22]=[i("h4",{id:"整数集合-intset-在小集合且所有成员均为整数时-用作-set-的底层实现。",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#整数集合-intset-在小集合且所有成员均为整数时-用作-set-的底层实现。"},[i("span",null,[s("整数集合（Intset）: 在小集合且所有成员均为整数时，用作 "),i("code",null,"Set"),s(" 的底层实现。")])])],-1),i("ul",null,[i("li",null,"只能存储 16 位、32 位或 64 位整数，并根据需要自动升级内部表示形式。"),i("li",null,"确保成员唯一性并维持有序排列。"),i("li",null,"高效利用内存空间。")],-1),i("p",null,"应用场景：特别适合存储少量整数值的小型集合。",-1)])),tab3:a(({value:n,isActive:t})=>l[23]||(l[23]=[i("h4",{id:"压缩列表-ziplist-listpack-用于优化小集合或短序列的存储。",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#压缩列表-ziplist-listpack-用于优化小集合或短序列的存储。"},[i("span",null,"压缩列表（Ziplist / Listpack）: 用于优化小集合或短序列的存储。")])],-1),i("ul",null,[i("li",null,"将所有元素连续地存储在一个内存块中，避免指针带来的额外开销。"),i("li",null,"使用变长编码表示每个元素及其长度信息。"),i("li",null,"允许在头部或尾部高效地插入和删除元素。"),i("li",null,"支持不同类型的数据（整数、字符串），并通过混合编码方式选择最合适的表示方法。")],-1),i("p",null,"应用场景：适用于存储小集合或短序列的数据，如小型 List、Set 和 ZSet",-1)])),tab4:a(({value:n,isActive:t})=>l[24]||(l[24]=[i("h4",{id:"跳跃表-skiplist-作为-redis-zset-的主要底层实现之一-确保成员按照分数排序。",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#跳跃表-skiplist-作为-redis-zset-的主要底层实现之一-确保成员按照分数排序。"},[i("span",null,"跳跃表（Skiplist）: 作为 Redis ZSet 的主要底层实现之一，确保成员按照分数排序。")])],-1),i("ul",null,[i("li",null,"通过多层索引加速查找、插入和删除操作，平均时间复杂度为 O(log N)。"),i("li",null,"新节点插入时，随机决定其层级，确保跳跃表高度合理。"),i("li",null,"每个节点不仅存储实际的数据项（成员及其分数），还维护指向同一层下一个节点及下一层相同位置节点的指针。")],-1),i("p",null,"应用场景：非常适合处理有序集合中的各种操作，如排行榜、优先级队列等。",-1),i("p",null,"为什么选择跳表？==> 相对于红黑树实现更为简单，多线程环境中并发更友好 (内存效率更高？)",-1)])),_:1}),l[30]||(l[30]=k(`<p>压缩列表通过紧凑存储减少内存开销，适用于小集合；跳表则通过多层索引加速查找、插入和删除操作，适用于需要高效排序和随机访问的大规模有序数据集。</p><h3 id="持久化策略" tabindex="-1"><a class="header-anchor" href="#持久化策略"><span>持久化策略</span></a></h3><ul><li><strong>Redis 的持久化机制有哪些？</strong><ul><li>常见的持久化机制包括： <ul><li><strong>RDB</strong>：定期将内存中的数据快照保存到磁盘。</li><li><strong>AOF</strong>：记录服务器执行的所有写操作命令，以便恢复数据。</li></ul></li></ul></li><li><strong>Redis 在生成 RDB 文件时如何处理请求？</strong><ul><li>生成RDB文件时，Redis会创建一个子进程来执行快照操作，父进程继续处理请求，子进程完成后将快照文件写入磁盘。</li></ul></li></ul><h3 id="击穿-穿透-雪崩" tabindex="-1"><a class="header-anchor" href="#击穿-穿透-雪崩"><span>击穿/穿透/雪崩</span></a></h3><ul><li><strong>Redis 中的缓存击穿、缓存穿透和缓存雪崩是什么？</strong><ul><li><strong>缓存击穿</strong>：某个热点Key突然大量请求，导致缓存失效，所有请求直接打到数据库。</li><li><strong>缓存穿透</strong>：查询一个不存在的Key，导致每次查询都直接打到数据库。</li><li><strong>缓存雪崩</strong>：大量缓存在同一时间失效，导致所有请求直接打到数据库。</li></ul></li><li><strong>Redis 中如何保证缓存与数据库的数据一致性？</strong><ul><li>常见的方法包括： <ul><li><strong>双写</strong>：同时写入缓存和数据库。</li><li><strong>失效时间</strong>：为缓存设置合理的失效时间。</li><li><strong>缓存更新策略</strong>：使用更新或删除策略保持缓存和数据库一致。</li></ul></li></ul></li></ul><h3 id="大key和热点key" tabindex="-1"><a class="header-anchor" href="#大key和热点key"><span>大Key和热点Key</span></a></h3><ul><li><strong>Redis 中的 Big Key 问题是什么？如何解决？</strong><ul><li><strong>Big Key问题</strong>：大Key占用大量内存，影响Redis性能。</li><li><strong>解决方法</strong>： <ul><li><strong>分片</strong>：将大Key拆分成多个小Key。</li><li><strong>使用更合适的数据结构</strong>：例如使用Ziplist或Hash。</li></ul></li></ul></li><li><strong>如何解决 Redis 中的热点 key 问题？</strong><ul><li><strong>热点Key问题</strong>：某些Key被频繁访问，导致性能瓶颈。</li><li><strong>解决方法</strong>： <ul><li><strong>数据分片</strong>：将热点Key分散到多个节点。</li><li><strong>缓存层</strong>：在应用层或CDN层缓存热点Key。</li><li><strong>布隆过滤器</strong>：减少不必要的查询。</li></ul></li></ul></li></ul><h3 id="内存淘汰策略" tabindex="-1"><a class="header-anchor" href="#内存淘汰策略"><span>内存淘汰策略</span></a></h3><ul><li><strong>Redis 中有哪些内存淘汰策略？</strong><ul><li>常见的内存淘汰策略包括： <ul><li><strong>noeviction</strong>：不淘汰数据，达到最大内存限制时返回错误。</li><li><strong>allkeys-lru</strong>：使用LRU算法淘汰任意键。</li><li><strong>volatile-lru</strong>：使用LRU算法淘汰设置了过期时间的键。</li><li><strong>allkeys-random</strong>：随机淘汰任意键。</li><li><strong>volatile-random</strong>：随机淘汰设置了过期时间的键。</li><li><strong>volatile-ttl</strong>：优先淘汰TTL值最小的键。</li></ul></li></ul></li><li><strong>Redis 中的内存碎片化是什么？如何进行优化？</strong><ul><li><strong>内存碎片化</strong>：由于频繁的内存分配和释放，导致内存空间分散。</li><li><strong>优化方法</strong>： <ul><li><strong>重启Redis</strong>：定期重启Redis实例，回收内存。</li><li><strong>调整内存分配策略</strong>：使用更合理的内存分配策略。</li><li><strong>使用内存碎片整理工具</strong>：使用第三方工具进行内存碎片整理。</li></ul></li></ul></li></ul><h3 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁"><span>分布式锁</span></a></h3><ul><li><p><strong>Redis 中如何实现分布式锁？</strong></p><ul><li>可以使用Redis的<code>SETNX</code>命令实现简单的分布式锁。</li><li>示例：<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setnx</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;lock&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;value&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 获取锁成功，执行业务逻辑</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 业务逻辑</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 释放锁</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">del</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;lock&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 获取锁失败</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong>分布式锁在未完成逻辑前过期怎么办？</strong></p><ul><li>可以在设置锁时设置一个合理的超时时间，并在释放锁时进行双重检查。</li><li>示例：<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">long</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> expireTime </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">currentTimeMillis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 30000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 30秒超时</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setnx</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;lock&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">valueOf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(expireTime))</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 获取锁成功</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> existingExpireTime </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;lock&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (existingExpireTime </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Long</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">parseLong</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(existingExpireTime)</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">currentTimeMillis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 锁已过期，尝试重新获取锁</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> currentExpireTime </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getSet</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;lock&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">valueOf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(expireTime));</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">currentExpireTime</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">equals</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(existingExpireTime)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 成功获取锁</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 获取锁失败</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 获取锁失败</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong>Redis 的 Red Lock 是什么？你了解吗？</strong></p><ul><li>Red Lock是一种改进的分布式锁算法，通过多个Redis实例来提高锁的可靠性和可用性。</li><li>示例：<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RedissonClient</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> redisson </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Redisson</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">create</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RLock</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> lock </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redisson</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;myLock&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 业务逻辑</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong>Redis 实现分布式锁时可能遇到的问题有哪些？</strong></p><ul><li>常见问题包括： <ul><li><strong>锁过期</strong>：锁在业务逻辑未完成前过期。</li><li><strong>死锁</strong>：多个节点竞争锁导致死锁。</li><li><strong>网络分区</strong>：网络问题导致锁无法正常释放。</li></ul></li></ul></li><li><p><strong>说说 Redisson 分布式锁的原理？</strong></p><ul><li><strong>Redisson分布式锁</strong>：基于Redis实现的分布式锁，提供了丰富的功能和更高的可靠性。</li><li><strong>原理</strong>： <ul><li><strong>可重入锁</strong>：支持可重入，多次获取锁不会阻塞。</li><li><strong>公平锁</strong>：支持公平锁，按请求顺序获取锁。</li><li><strong>锁过期保护</strong>：通过WatchDog机制自动续期，防止锁过期。</li></ul></li><li><strong>使用示例</strong>：<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RedissonClient</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> redisson </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Redisson</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">create</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RLock</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> lock </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redisson</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;myLock&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 业务逻辑</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h2 id="性能及应用场景" tabindex="-1"><a class="header-anchor" href="#性能及应用场景"><span>性能及应用场景</span></a></h2><ul><li><strong>Redis 通常应用于哪些场景？</strong><ul><li>常见的应用场景包括： <ul><li><strong>缓存</strong>：作为高速缓存层，提高数据访问速度。</li><li><strong>消息队列</strong>：实现消息传递和任务队列。</li><li><strong>会话存储</strong>：存储用户会话信息。</li><li><strong>计数器</strong>：统计网站访问量、用户行为等。</li><li><strong>排行榜</strong>：实现实时排行榜功能。</li><li><strong>地理位置</strong>：存储和查询地理位置信息。</li></ul></li></ul></li></ul><h3 id="快-源码设计" tabindex="-1"><a class="header-anchor" href="#快-源码设计"><span>快/源码设计</span></a></h3><ul><li><p><strong>Redis 为什么这么快？</strong></p><ul><li>Redis之所以快，主要有以下几个原因： <ul><li><strong>内存存储</strong>：数据存储在内存中，访问速度快。</li><li><strong>单线程模型</strong>：避免了多线程间的上下文切换开销。</li><li><strong>高效的内存管理</strong>：使用自定义的数据结构和内存分配算法。</li><li><strong>网络通信优化</strong>：使用多路复用IO模型，处理大量并发连接。</li></ul></li></ul></li><li><p><strong>Redis 源码中有哪些巧妙的设计，举几个典型的例子？</strong></p><ul><li><strong>内存管理</strong>：使用自定义的内存分配器，减少内存碎片。</li><li><strong>多路复用IO</strong>：使用epoll/kqueue等高性能IO多路复用技术。</li><li><strong>事件驱动</strong>：使用事件驱动模型，处理大量并发连接。</li><li><strong>数据结构优化</strong>：使用Ziplist、Quicklist等优化数据结构，减少内存占用。</li></ul></li></ul><h3 id="性能优化" tabindex="-1"><a class="header-anchor" href="#性能优化"><span>性能优化</span></a></h3><ul><li><strong>Redis 性能瓶颈时如何处理？</strong><ul><li>常见的性能优化方法包括： <ul><li><strong>增加内存</strong>：扩大Redis实例的内存容量。</li><li><strong>优化数据结构</strong>：选择合适的数据结构，减少内存占用。</li><li><strong>使用Pipeline</strong>：减少网络往返次数，提高性能。</li><li><strong>分片</strong>：将数据分散到多个Redis实例。</li><li><strong>监控和调优</strong>：使用监控工具定期检查性能，进行调优。</li></ul></li></ul></li></ul><h3 id="多线程和虚拟内存" tabindex="-1"><a class="header-anchor" href="#多线程和虚拟内存"><span>多线程和虚拟内存</span></a></h3><ul><li><p><strong>为什么 Redis 设计为单线程？6.0 版本为何引入多线程？</strong></p><ul><li><strong>单线程设计</strong>：避免多线程间的上下文切换开销，提高性能。</li><li><strong>6.0版本引入多线程</strong>：为了处理IO密集型任务，如网络IO和文件IO，提高整体性能。</li></ul></li><li><p><strong>Redis 的虚拟内存（VM）机制是什么？</strong></p><ul><li><strong>虚拟内存机制</strong>：允许Redis将部分数据换出到磁盘，减少内存占用。</li><li><strong>工作原理</strong>：Redis将不常用的数据换出到磁盘，当需要访问时再换入内存。</li></ul></li></ul><h2 id="高级功能和架构" tabindex="-1"><a class="header-anchor" href="#高级功能和架构"><span>高级功能和架构</span></a></h2><h3 id="主从复制" tabindex="-1"><a class="header-anchor" href="#主从复制"><span>主从复制</span></a></h3><ul><li><strong>Redis 主从复制的实现原理是什么？</strong><ul><li>主从复制通过主节点将数据同步到从节点。主节点将写操作记录到replication buffer中，从节点定期请求同步数据，主节点将数据发送给从节点。</li></ul></li><li><strong>Redis 主从复制的常见拓扑结构有哪些？</strong><ul><li>常见的拓扑结构包括： <ul><li><strong>单主单从</strong>：一个主节点和一个从节点。</li><li><strong>单主多从</strong>：一个主节点和多个从节点。</li><li><strong>级联复制</strong>：从节点再作为其他从节点的主节点。</li></ul></li></ul></li></ul><h3 id="集群和哨兵机制" tabindex="-1"><a class="header-anchor" href="#集群和哨兵机制"><span>集群和哨兵机制</span></a></h3><ul><li><p><strong>Redis 集群的实现原理是什么？</strong></p><ul><li>Redis集群通过分片（sharding）技术将数据分布到多个节点上。每个节点负责一部分数据，通过哈希槽（hash slot）来确定数据的归属。</li></ul></li><li><p><strong>Redis 集群会出现脑裂问题吗？</strong></p><ul><li>Redis集群通过哨兵机制和多数派选举来避免脑裂问题。只有超过半数的节点同意，才能进行主从切换。</li></ul></li><li><p><strong>在 Redis 集群中，如何根据键定位到对应的节点？</strong></p><ul><li>通过哈希槽（hash slot）来定位键。每个键通过CRC16算法计算哈希值，然后取模得到哈希槽编号，根据哈希槽编号找到对应的节点。</li></ul></li><li><p><strong>Redis 的哨兵机制是什么？</strong></p><ul><li>哨兵机制用于监控和管理Redis集群的高可用性。哨兵节点会定期检查主节点的健康状况，如果主节点宕机，哨兵会自动进行主从切换。</li></ul></li></ul><h3 id="redis事务" tabindex="-1"><a class="header-anchor" href="#redis事务"><span>Redis事务</span></a></h3><ul><li><strong>Redis 支持事务吗？如何实现？</strong><ul><li>Redis支持事务，通过<code>MULTI</code>、<code>EXEC</code>、<code>DISCARD</code>和<code>WATCH</code>命令来实现事务。</li><li><strong>MULTI</strong>：开始事务。</li><li><strong>EXEC</strong>：执行事务。</li><li><strong>DISCARD</strong>：取消事务。</li><li><strong>WATCH</strong>：监视键的变化，如果在事务执行前键被修改，事务将被取消。</li></ul></li></ul><h3 id="lua脚本" tabindex="-1"><a class="header-anchor" href="#lua脚本"><span>Lua脚本</span></a></h3><ul><li><strong>Redis 的 Lua 脚本功能是什么？如何使用？</strong><ul><li>Redis支持使用Lua脚本执行复杂的操作。通过<code>EVAL</code>命令执行Lua脚本，可以实现原子操作。</li><li>示例：<div class="language-lua line-numbers-mode" data-highlighter="shiki" data-ext="lua" data-title="lua" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">EVAL</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;return redis.call(&#39;INCR&#39;, KEYS[1])&quot; </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> counter</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="pipeline管道" tabindex="-1"><a class="header-anchor" href="#pipeline管道"><span>Pipeline管道</span></a></h3><ul><li><strong>Redis 的 Pipeline 功能是什么？</strong><ul><li>Pipeline功能允许客户端一次性发送多个命令，减少网络往返次数，提高性能。</li><li>示例：<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">pipelined</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(jedis </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    jedis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;key1&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;value1&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    jedis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;key2&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;value2&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h3 id="redis客户端" tabindex="-1"><a class="header-anchor" href="#redis客户端"><span>Redis客户端</span></a></h3><ul><li><strong>你在项目中使用的 Redis 客户端是什么？</strong><ul><li>常见的Redis客户端包括Jedis、Lettuce、Redisson等。</li><li><strong>Jedis</strong>：Java客户端，轻量级，使用广泛。</li><li><strong>Lettuce</strong>：Java客户端，支持Netty，性能较好。</li><li><strong>Redisson</strong>：Java客户端，提供了丰富的高级功能，如分布式锁。</li></ul></li></ul>`,32))])}const v=p(u,[["render",A],["__file","redis.html.vue"]]),b=JSON.parse('{"path":"/java/interview/frame/redis.html","title":"Redis","lang":"en-US","frontmatter":{"order":30,"title":"Redis","description":"Redis缓存基础 Redis之所以能够实现高性能，主要得益于其单线程模型、内存操作、IO多路复用机制 单线程：由于所有命令都在同一个线程中顺序执行，因此不需要复杂的锁机制来保护共享资源，避免了多线程环境下的竞态条件和死锁问题。减少上下文切换开销。 基于内存操作：RAM访问时间远低于磁盘I/O。 非阻塞：Redis采用了基于epoll的事件驱动架构，可...","head":[["meta",{"property":"og:url","content":"https://x.app/java/interview/frame/redis.html"}],["meta",{"property":"og:site_name","content":"doc"}],["meta",{"property":"og:title","content":"Redis"}],["meta",{"property":"og:description","content":"Redis缓存基础 Redis之所以能够实现高性能，主要得益于其单线程模型、内存操作、IO多路复用机制 单线程：由于所有命令都在同一个线程中顺序执行，因此不需要复杂的锁机制来保护共享资源，避免了多线程环境下的竞态条件和死锁问题。减少上下文切换开销。 基于内存操作：RAM访问时间远低于磁盘I/O。 非阻塞：Redis采用了基于epoll的事件驱动架构，可..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-04-01T13:21:59.000Z"}],["meta",{"property":"article:author","content":"ventixy"}],["meta",{"property":"article:modified_time","content":"2025-04-01T13:21:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-01T13:21:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ventixy\\",\\"url\\":\\"https://www.ventix.top\\"}]}"]]},"headers":[{"level":2,"title":"Redis缓存基础","slug":"redis缓存基础","link":"#redis缓存基础","children":[{"level":3,"title":"常用数据类型","slug":"常用数据类型","link":"#常用数据类型","children":[]},{"level":3,"title":"底层数据结构","slug":"底层数据结构","link":"#底层数据结构","children":[]},{"level":3,"title":"持久化策略","slug":"持久化策略","link":"#持久化策略","children":[]},{"level":3,"title":"击穿/穿透/雪崩","slug":"击穿-穿透-雪崩","link":"#击穿-穿透-雪崩","children":[]},{"level":3,"title":"大Key和热点Key","slug":"大key和热点key","link":"#大key和热点key","children":[]},{"level":3,"title":"内存淘汰策略","slug":"内存淘汰策略","link":"#内存淘汰策略","children":[]},{"level":3,"title":"分布式锁","slug":"分布式锁","link":"#分布式锁","children":[]}]},{"level":2,"title":"性能及应用场景","slug":"性能及应用场景","link":"#性能及应用场景","children":[{"level":3,"title":"快/源码设计","slug":"快-源码设计","link":"#快-源码设计","children":[]},{"level":3,"title":"性能优化","slug":"性能优化","link":"#性能优化","children":[]},{"level":3,"title":"多线程和虚拟内存","slug":"多线程和虚拟内存","link":"#多线程和虚拟内存","children":[]}]},{"level":2,"title":"高级功能和架构","slug":"高级功能和架构","link":"#高级功能和架构","children":[{"level":3,"title":"主从复制","slug":"主从复制","link":"#主从复制","children":[]},{"level":3,"title":"集群和哨兵机制","slug":"集群和哨兵机制","link":"#集群和哨兵机制","children":[]},{"level":3,"title":"Redis事务","slug":"redis事务","link":"#redis事务","children":[]},{"level":3,"title":"Lua脚本","slug":"lua脚本","link":"#lua脚本","children":[]},{"level":3,"title":"Pipeline管道","slug":"pipeline管道","link":"#pipeline管道","children":[]},{"level":3,"title":"Redis客户端","slug":"redis客户端","link":"#redis客户端","children":[]}]}],"git":{"createdTime":1736522381000,"updatedTime":1743513719000,"contributors":[{"name":"drizzle","email":"msdrizzle@outlook.com","commits":2}]},"readingTime":{"minutes":15.87,"words":4762},"filePathRelative":"java/interview/frame/redis.md","localizedDate":"January 10, 2025","excerpt":"<h2>Redis缓存基础</h2>\\n<p>Redis之所以能够实现高性能，主要得益于其单线程模型、内存操作、IO多路复用机制</p>\\n<ul>\\n<li>\\n<p>单线程：由于所有命令都在同一个线程中顺序执行，因此不需要复杂的锁机制来保护共享资源，避免了多线程环境下的竞态条件和死锁问题。减少上下文切换开销。</p>\\n</li>\\n<li>\\n<p>基于内存操作：RAM访问时间远低于磁盘I/O。</p>\\n</li>\\n<li>\\n<p>非阻塞<a href=\\"/java/core/io/nio.html#i-o%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86\\" target=\\"_blank\\">IO多路复用</a>：Redis采用了基于epoll的事件驱动架构，可以在不阻塞主线程的情况下同时监听多个客户端连接的状态变化。通过异步读取和写入网络套接字，Redis可以最大限度地利用可用带宽，而不必等待每一个单独的操作完成。</p>\\n</li>\\n</ul>","autoDesc":true}');export{v as comp,b as data};
