import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,b as n,a as s,d as l,o as t}from"./app-BzKUd-8z.js";const a={},r={class:"hint-container tip"},p={class:"MathJax",jax:"SVG",style:{position:"relative"}},d={style:{"vertical-align":"0"},xmlns:"http://www.w3.org/2000/svg",width:"2.119ex",height:"1.887ex",role:"img",focusable:"false",viewBox:"0 -833.9 936.6 833.9","aria-hidden":"true"};function c(g,i){return t(),e("div",null,[i[7]||(i[7]=n(`<p>传输层（Transport Layer）：通过 <mark>端口机制</mark> 和 <strong>端到端逻辑信道</strong>，实现了真正意义上的进程间通信。传输层协议仅在网络边缘的主机中实现，路由器、交换机等网络核心设备仅处理下三层（网络层、数据链路层、物理层）</p><ul><li>TCP：提供面向连接、可靠的服务（如数据重传、流量控制）</li><li>UDP：提供无连接、尽力而为的服务（适用于实时视频等低延迟场景）</li></ul><p>运输层通过端口号标识进程，使数据能够准确交付给目标应用（如HTTP默认端口80）</p><div class="hint-container info"><p class="hint-container-title">端口号分类</p><ol><li><p><strong>知名端口（Well-Known Ports）</strong>：<code>0-1023</code>， 这些端口通常被分配给系统级的服务和应用程序，如HTTP (80), HTTPS (443), FTP (21), SSH (22)等。</p></li><li><p><strong>注册端口（Registered Ports）</strong>：<code>1024-49151</code>，可以由用户进程或应用程序动态选择，但通常用于特定的应用程序或服务，这些应用需要向IANA（互联网号码分配机构）注册以避免冲突</p></li><li><p><strong>动态/私有端口（Dynamic/Private Ports）</strong>：<code>49152-65535</code>，通常用于临时连接，当客户端发起请求时，操作系统会自动为该连接分配一个未使用的端口号。</p></li></ol></div><p>若要检查某个端口是否已被占用，可以根据所用的操作系统选择合适的命令进行查询</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">netstat</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -tuln</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ss</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -tuln</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">netstat</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -anp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">grep</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> port</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lsof</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -i:port</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lsof</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -i</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -P</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">grep</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3306</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用户可自由选择的端口号主要是从49152到65535的动态/私有端口区间。开发过程中，为了确保端口不冲突，建议先确认所需使用的端口是否空闲</p><hr><h2 id="transmission-control" tabindex="-1"><a class="header-anchor" href="#transmission-control"><span>Transmission Control</span></a></h2><p><span style="color:purple;"><strong>传输控制协议（TCP，Transmission Control Protocol）</strong> 提供了一种可靠的、面向连接的服务，用于在网络上的不同主机之间传输数据</span>。TCP确保数据能够准确无误地从源端传递到目的端，并且按正确的顺序重组。</p><ul><li><p><span style="color:red;">面向连接</span>：通信前需要建立连接（三次握手），通信结束后释放连接（四次挥手）。</p></li><li><p><span style="color:#1E90FF;">可靠传输</span>：通过确认机制、重传机制、流量控制和拥塞控制确保数据可靠传输。</p></li><li><p><span style="color:green;">全双工通信</span>：双方可以同时发送和接收数据。</p></li><li><p><span style="color:orange;">字节流服务</span>：将数据视为无结构的字节流，不保留消息边界。</p></li></ul><p>应用场景：需要可靠传输的应用，如HTTP、FTP、SMTP等。</p><hr><h3 id="tcp协议数据报" tabindex="-1"><a class="header-anchor" href="#tcp协议数据报"><span>TCP协议数据报</span></a></h3><p>TCP数据报（TCP段）由首部和数据两部分组成。首部长度为20字节（无选项时），最大长度为60字节（含选项）。</p><figure><img src="https://image.ventix.top/img02/20220210151434121.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>注意：<span style="color:red;">TCP并不以报文段为单位来编号，而是对每个字节进行编号。这意味着每一个发送出去的字节都有一个唯一的序列号</span></p><ol><li><p>Source Port（源端口）：标识发送方的应用程序端口号，通常由客户端临时分配</p></li><li><p>Destination Port（目标端口）：标识接收方的应用程序端口号（对应服务器上的特定服务）</p></li><li><p><strong>Sequence Number（序列号）</strong>：标识了该报文段中第一个字节的数据在整个数据流中的位置。例：假设客户端想要发送一段较长的消息给服务器，这条消息被分割成若干个TCP报文段发送：</p><ul><li>客户端首先发送一个报文段，假设序列号设为seq=1000，长度为1000字节（即包含字节1000至1999）。<span style="color:orange;">注意：初始序列号（ISN, Initial Sequence Number）并不是固定从0开始的，而是为了减少被攻击的风险由操作系统根据一定的算法生成的 </span></li><li>如果服务器成功接收了这个报文段，它将回复一个ACK报文，其中ack=2000，表明它期待下一个报文段的起始序列号为2000。</li><li>客户端接着发送下一个报文段，序列号为seq=2000，长度也为1000字节（即包含字节2000至2999）</li></ul></li><li><p><strong>Acknowledgment Number（确认号）</strong>：期望接收的下一个字节的序列号，仅当ACK标志置1时有效。<span style="color:gray;">例：如果接收方收到了序列号范围从seq=1000到seq=1999的所有字节，则它会在回复的ACK报文中设置ack=2000，告诉发送方它希望接下来收到序列号为2000及之后的数据</span></p></li><li><p>数据偏移（Data Offset）/首部长度（Header Length）：表示TCP首部的长度，单位为4字节。最小值为5（对应20字节），最大值为15（对应60字节）</p></li><li><p>Reserved（保留字段）：保留供未来使用，必须为0。目前部分被用于显式拥塞通知（ECN）</p></li><li><p><strong>Control Flags（控制标志）</strong>：用于控制TCP连接的状态和数据传输</p><ul><li>URG（Urgent）：置1时，紧急指针有效，指示紧急数据的位置。紧急数据直接传递至应用层，不进入接收缓冲区</li><li><strong>ACK（Acknowledgment）</strong>：置1时，确认号字段有效</li><li>PSH（Push）：要求接收方立即处理数据，而非缓存，接收方应立即将数据交给应用层</li><li>RST（Reset）：重置连接（强制终止异常连接）</li><li><strong>SYN（Synchronize）</strong>：用于连接建立，同步初始序列号</li><li>FIN（Finish）：用于正常关闭连接，表示数据发送完毕</li></ul></li><li><p>Window Size（窗口大小）：流量控制的关键字段，表示接收方可接收的数据量（单位：字节），通过滑动窗口机制动态调整发送速率，避免接收方缓冲区溢出</p></li><li><p>Checksum（校验和）：验证TCP首部、数据及伪头部(包含IP)的完整性，检测传输错误</p></li><li><p>Urgent Pointer（紧急指针）：指示紧急数据在数据流中的结束位置（仅在URG标志为1时有效），实际应用较少，部分实现可能忽略此字段</p></li><li><p>Options（选项）：提供额外的功能。常见选项：MSS（Maximum Segment Size）：协商数据段的最大长度，SACK（Selective Acknowledgment）：允许接收方指明已接收的非连续数据块，Timestamp：用于计算往返时间（RTT）和防止序号回绕</p></li><li><p>填充（Padding）：确保选项字段的总长度为4字节的整数倍，通过填充0实现</p></li></ol><hr><h3 id="tcp连接的建立" tabindex="-1"><a class="header-anchor" href="#tcp连接的建立"><span>TCP连接的建立</span></a></h3><p><span style="color:red;">TCP是面向连接的协议，进行通信之前必须先建立连接（三次握手）</span>。这个过程中涉及到以下几个关键TCP报文首部字段及其变化：</p><ul><li>源端口号（Source Port）和目的端口号（Destination Port）</li><li>序列号（Sequence Number, 32位）：对于SYN报文段，此值代表初始序列号（ISN）</li><li>确认号（Acknowledgment Number, 32位）：期望接收的下一个字节的序列号</li><li>标志位（Flags）： SYN-同步序列号，用于发起连接请求， ACK-确认字符有效， FIN-终止连接</li></ul><p><span style="color:purple;">建立连接之前 服务端持续监听特定端口（<code>LISTEN</code>状态），等待客户端发起连接请求</span></p><div class="hint-container tip"><p class="hint-container-title">TCP连接状态</p><p>TCP连接的状态包括： <code>CLOSED</code>（关闭）、<code>LISTEN</code>（监听）、<code>SYN_SENT</code>（等待对方的确认）、<code>SYN_RCVD</code>（收到SYN后的状态）、<code>ESTABLISHED</code>（已建立连接）、<code>FIN_WAIT_1/2</code>、<code>TIME_WAIT</code>等</p></div><p>注：在下面建立连接的描述过程中，SYN、ACK指的是标志位（Flag bits），而序列号（Sequence Number）和确认号（Acknowledgment Number）则是具体的32位数值字段，为了简洁常记作：序列号<code>seq</code> 和 确认号 <code>ack</code></p><figure><img src="https://image.ventix.top/img02/20230210190206103.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container important"><p class="hint-container-title">TCP建立连接的过程（三次握手）</p><ol><li><strong>第一次握手（SYN）</strong>：客户端主动发送一个SYN报文段到服务端（状态变化：<code>CLOSED</code> --&gt; <code>SYN_SENT</code>）</li></ol><ul><li><mark>设置SYN标志位为1</mark></li><li>生成一个初始序列号（假设为<code>x</code>），并将其放在序列号（Sequence Number）字段中</li></ul><ol start="2"><li><strong>第二次握手（SYN+ACK）</strong>：服务端收到SYN报文后，知道客户端想要建立连接，发送一个SYN+ACK报文段给客户端。状态变化：<code>LISTEN</code> --&gt; <code>SYN_RCVD</code></li></ol><ul><li><mark>设置SYN和ACK标志位为1</mark></li><li>生成自己的初始序列号（假设为<code>y</code>），设置序列号（Sequence Number）字段设为<code>y</code></li><li>确认号（Acknowledgment Number）字段设为<code>x+1</code></li></ul><ol start="3"><li><strong>第三次握手（ACK）</strong>：客户端动收到SYN+ACK报文段后，发送一个ACK报文段作为响应，确认了服务端同意建立连接</li></ol><ul><li><mark>设置ACK标志位为1</mark></li><li>序列号（Sequence Number）字段设为<code>x+1</code></li><li>确认号（Acknowledgment Number）字段设为<code>y+1</code></li></ul><p>可以带上第一个数据包，但通常不包含应用层数据</p></div><p>最终双方都进入<code>ESTABLISHED</code>状态，表明连接已经成功建立，可以开始数据传输。</p><hr><h3 id="tcp连接的终止" tabindex="-1"><a class="header-anchor" href="#tcp连接的终止"><span>TCP连接的终止</span></a></h3><p><strong>四次挥手（Four-Way Handshake）即TCP连接终止的过程</strong>，用于确保双方都能安全地关闭连接。由于TCP连接是全双工的（即数据可以在两个方向上同时传输），因此每一方都需要独立地通知对方自己已经完成了数据发送并准备好关闭连接。</p><p>四次挥手过程中的关键字段：</p><ul><li><strong>FIN (Finish)</strong>：标志位，表示发送端已经完成数据发送，希望断开连接。</li><li><strong>ACK (Acknowledgment)</strong>：标志位，确认字符有效。</li><li><strong>Sequence Number (序列号)</strong>：标识该报文段中第一个字节的数据在整个数据流中的位置</li><li><strong>Acknowledgment Number (确认号)</strong>：表示期望收到对方下一个报文段的第一个数据字节的序号</li></ul><p>理论上客户端和服务器都可以发起主动关闭，但是更多的情况下是客户端主动发起</p><figure><img src="https://image.ventix.top/img02/20230210232822520.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container info"><p class="hint-container-title">四次挥手（Four-Way Handshake）</p><p><span style="color:#1E90FF;"><strong>第一次挥手（FIN from Client）</strong></span></p><ul><li><p>客户端：发送一个FIN报文段给服务器。状态从<code>ESTABLISHED</code>变为<code>FIN_WAIT_1</code></p><ul><li>设置FIN标志位为1</li><li>序列号设为<code>u</code>（假设这是客户端最后一个已发送的数据包的序列号）</li></ul></li><li><p>服务器动作： 收到FIN报文后，知道客户端不再发送数据了。状态保持在<code>ESTABLISHED</code>状态，直到准备关闭自己的发送通道。</p></li></ul><p><span style="color:#1E90FF;"><strong>第二次挥手（ACK from Server）</strong></span></p><ul><li><p>服务器：发送一个ACK报文段给客户端作为响应。状态从<code>ESTABLISHED</code>变为<code>CLOSE_WAIT</code></p><ul><li>设置ACK标志位为1</li><li>确认号设为<code>u+1</code>（因为客户端希望收到的下一个字节是<code>u+1</code>）</li></ul></li><li><p>客户端： 收到ACK报文后，确认服务器已经收到了关闭请求。状态<code>FIN_WAIT_1</code>变为<code>FIN_WAIT_2</code></p></li></ul><p><span style="color:#1E90FF;"><strong>第三次挥手（FIN from Server）</strong></span></p><ul><li><p>当服务器也完成所有数据发送时，发送一个FIN报文段给客户端。状态从<code>CLOSE_WAIT</code>变为<code>LAST_ACK</code></p><ul><li>设置FIN标志位为1</li><li>设置ACK标志位为1</li><li>序列号设为<code>v</code>（假设这是服务器最后一个已发送的数据包的序列号）</li></ul></li><li><p>客户端：收到FIN报文后，知道服务器也不再发送数据了，状态保持在<code>FIN_WAIT_2</code>状态</p></li></ul><p><span style="color:#1E90FF;"><strong>第四次挥手（ACK from Client）</strong></span></p><ul><li><p>客户端：发送一个ACK报文段给服务器作为响应</p><ul><li>设置ACK标志位为1</li><li>确认号设为<code>v+1</code>（因为服务器希望收到的下一个字节是<code>v+1</code>）</li><li><strong>状态</strong>：从<code>FIN_WAIT_2</code>变为<code>TIME_WAIT</code>，等待一段时间（通常是最大分段寿命的两倍，以确保网络上的所有报文都被清除）后进入<code>CLOSED</code>状态</li></ul></li><li><p>服务器： 收到ACK报文后，确认客户端已经收到了关闭请求。状态从<code>LAST_ACK</code>变为<code>CLOSED</code></p></li></ul></div><p>实际场景下会断开连接的情况</p><ol><li><p><strong>正常关闭</strong>：当应用程序逻辑决定不再需要维持连接时，例如用户关闭浏览器标签页或退出应用程序。</p></li><li><p><strong>超时</strong>：如果一方在一定时间内没有收到另一方的任何数据或心跳信号（如TCP Keepalive机制），可能会认为连接已失效，并主动发起关闭请求。</p></li><li><p><strong>资源限制</strong>：当系统资源达到上限（如文件描述符数量、内存等），操作系统可能强制关闭某些连接以释放资源。</p></li><li><p><strong>错误处理</strong>：如果检测到严重的协议错误（如接收到无法解析的数据包），可能会触发连接关闭以防止进一步的问题。</p></li><li><p><strong>异常断电或崩溃</strong>：物理层面上的中断（如电源故障、硬件损坏）或者软件层面的崩溃（如进程意外终止）也会导致连接被断开。</p></li></ol><hr><h3 id="mss和mtu" tabindex="-1"><a class="header-anchor" href="#mss和mtu"><span>MSS和MTU</span></a></h3><p><span style="color:#1E90FF;"><strong>MSS，即最大段大小（Maximum Segment Size）</strong></span>，是指在TCP连接中，一个TCP报文段（不包括TCP和IP头部）所能承载的最大数据量。TCP通过MSS确保每个段封装成IP数据报时不超MTU，避免IP分片，因为IP分片会增加网络复杂性和潜在的数据丢失风险</p><div class="hint-container info"><p class="hint-container-title">MSS 和 选项字段</p><p>MSS是在TCP三次握手期间通过SYN和SYN/ACK报文中的选项字段（Options Field）进行协商的</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">MSS</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Option:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Kind=2,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Length=4,</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> MSS</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Value=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1460</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>Kind (1字节)：表示这是一个MSS选项，值为2</li><li>Length (1字节)：表示整个选项的长度，对于MSS选项来说，长度固定为4字节</li><li>MSS Value (2字节)：表示建议的最大段大小，单位是字节</li></ul><p>客户端和服务端都可以提出自己的MSS值，最终双方会选择较小的那个值作为通信的基础</p></div><p>MSS值通常为 <code>MTU - IP头（20字节） - TCP头（20字节）</code> 例如 MTU为1500字节，则MSS为1460字节</p><hr><p><span style="color:#1E90FF;"><strong>MTU（最大传输单元，Maximum Transmission Unit）</strong></span> 指网络中每个数据帧的最大长度（以字节为单位），这是在特定链路层技术下允许的最大数据包大小。</p><p>MTU由物理网络介质和技术决定，以太网（Ethernet）典型的MTU值是1500字节</p><hr><h3 id="tcp重传机制" tabindex="-1"><a class="header-anchor" href="#tcp重传机制"><span>TCP重传机制</span></a></h3><p>TCP重传机制用于确保丢失或损坏的数据包能够被重新发送并正确接收</p><p><span style="color:#1E90FF;"><strong>超时重传（Timeout Retransmission）</strong></span>：当发送方发送一个数据段后，会启动一个定时器（称为重传定时器）。如果在定时器到期之前没有收到该数据段的确认（ACK），则认为该数据段可能丢失，并触发重传</p><div class="hint-container info"><p class="hint-container-title">超时重传（Timeout Retransmission）示例</p><p>假设发送方发送了一个序列号为seq=1000的数据段，并设置了超时时间为1秒。如果在1秒内没有收到对应的ACK，发送方将重传该数据段</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">发送方</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> -&gt; [seq=1000] -&gt; 网络</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1秒后无响应</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">发送方</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> -&gt; [seq=1000] -&gt; 网络</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><p>Retransmission Timeout (RTO)：重传超时时间，由TCP根据网络状况动态调整</p><hr><p><span style="color:#1E90FF;"><strong>快速重传（Fast Retransmit）</strong></span>：快速重传是一种优化机制，允许发送方在不等待定时器超时的情况下更快地检测到数据段丢失。具体来说，如果发送方连续收到三个重复的ACK（即接收方已经收到了后续的数据段但未收到某个中间的数据段），则立即重传这个丢失的数据段</p><div class="hint-container info"><p class="hint-container-title">快速重传（Fast Retransmit）示例</p><p>假设发送方发送了序列号分别为<code>seq=1000</code>、<code>seq=1050</code>、<code>seq=1100</code>的数据段。接收方收到<code>seq=1050</code>和<code>seq=1100</code>，但未收到<code>seq=1000</code>，因此发送重复的ACK：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">接收方</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> -&gt; [ack=1000] -&gt; 发送方</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">接收方</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> -&gt; [ack=1000] -&gt; 发送方</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">接收方</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> -&gt; [ack=1000] -&gt; 发送方</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当发送方收到第三个重复的ACK时，立即重传<code>seq=1000</code>的数据段</p></div><hr><h3 id="sliding-window" tabindex="-1"><a class="header-anchor" href="#sliding-window"><span>Sliding Window</span></a></h3><p>在滑动窗口机制出现之前，TCP使用 <span style="color:orange;">停等协议（Stop-and-Wait）</span>，发送方每发送一个数据段后必须等待确认，效率低下。为了提高传输效率，滑动窗口机制被引入，允许发送方连续发送多个数据段，而不必等待每个数据段的确认</p><p><span style="color:red;"><strong>滑动窗口（Sliding Window）</strong> 机制主要用于提高效率和实现流量控制，确保发送方不会以超过接收方处理能力的速度发送数据，从而避免接收方缓冲区溢出导致的数据丢失</span></p><p><span style="color:purple;">接收方窗口大小（Receiver Window Size），也称为接收窗口或简称 rwnd </span>，指的是接收方当前可以接受的最大未确认数据量，这个值由接收方根据其缓冲区状态动态调整，并通过TCP报文中的窗口字段告知发送方</p><p>发送窗口可分为四个区：</p><figure><img src="https://image.ventix.top/img02/20230212153639272.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>滑动机制：发送方维护一个发送窗口（其中包含已经发送但尚未被确认的数据包），发送方可以在不等待确认的情况下继续发送新的数据包，直到发送窗口填满。随着接收方ACK确认，窗口右移，释放空间发送新数据</p><p>发送与确认：发送方将数据包发送到接收方。接收方收到数据包后，向发送方发送一个确认（ACK），表示已成功接收该数据包，<span style="color:green;">接收方通常会累积多个数据包的确认，只在接收到所有预期的数据包后才发送一次确认</span></p><ul><li><p>正常情况下的ACK确认和窗口大小调整：</p><ul><li>接收方根据自身的处理能力和缓冲区状态设定一个窗口大小，并在每个ACK中通知发送方。如果接收方处理能力强、缓冲区空间大，则会设置较大的窗口值，反之则设置较小的窗口值以限制发送速率</li><li><span style="color:purple;">通过动态调整window size，接收方能够有效地控制来自发送方的数据流，确保自身不会因为过载而丢弃数据包</span></li></ul></li><li><p>丢失或乱序到达的数据包处理：</p><ul><li>如果某些数据包丢失或者乱序到达，接收方仅对已连续接收到的最大序列号的数据包进行确认（即最大连续序号）。这意味着即使接收到了后续的数据包，但中间有丢失的数据包未被接收时，接收方不会对这些后续的数据包进行确认</li><li>对于发送方来说，若在超时时间内未收到某个数据包的确认，它将重传该数据包以及所有尚未被确认的数据包（根据具体的重传策略可能有所不同）</li></ul></li></ul><p>滑动窗口协议通过动态调整发送方和接收方之间的窗口大小（window size）来实现高效的通信，并允许接收方根据其处理能力或网络状况灵活地调整流量</p>`,66)),s("div",r,[i[4]||(i[4]=s("p",{class:"hint-container-title"},"窗口缩放选项（Window Scale Option）",-1)),i[5]||(i[5]=s("p",null,[l("传统的TCP头部只有16位用于表示接收窗口大小，这意味着最大的窗口大小为65535字节。为了支持更高速率的传输，TCP引入了窗口缩放选项（Window Scale Option），允许窗口大小扩展到更大的值。窗口缩放因子（Window Scale）是通过TCP "),s("code",null,"选项"),l(" 字段进行协商的。窗口缩放因子的选项格式为：")],-1)),i[6]||(i[6]=s("ul",null,[s("li",null,"Kind (1字节)：值为3。"),s("li",null,"Length (1字节)：值为3。"),s("li",null,"Shift Count (1字节)：表示窗口大小左移的位数（即缩放因子），范围通常是0到14之间")],-1)),s("p",null,[i[2]||(i[2]=l("假设缩放因子为6，这意味着实际窗口大小将是TCP报文中窗口字段值乘以 ")),s("mjx-container",p,[(t(),e("svg",d,i[0]||(i[0]=[n('<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path></g></g></g></g>',1)]))),i[1]||(i[1]=s("mjx-assistive-mml",{unselectable:"on",display:"inline"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("msup",null,[s("mn",null,"2"),s("mn",null,"6")])])],-1))]),i[3]||(i[3]=l(" （即64倍）"))])]),i[8]||(i[8]=n('<p>Window Scale 和 Window Size 的值是基于接收方当前可用的缓冲区空间动态确定的</p><hr><h3 id="flow-control" tabindex="-1"><a class="header-anchor" href="#flow-control"><span>Flow Control</span></a></h3><p>流量控制（Flow Control）：防止发送方发送数据的速度超过接收方处理数据的能力，避免接收方因缓冲区溢出而丢弃数据。</p><ul><li><p><strong>基于窗口的机制</strong>：接收方通过ACK报文中携带的窗口大小字段通知发送方当前能接受的最大数据量。发送方据此调整自己的发送速率，确保不会超出接收方的处理能力。</p></li><li><p><strong>动态调整</strong>：随着接收方处理完更多的数据，它会相应地增加窗口大小；反之亦然。</p></li></ul><p>数据传输期间发送方只能发送不超过接收方窗口大小的数据量。一旦窗口满载，发送方必须停止发送直到接收到新的ACK并得知窗口有空余</p><hr><h3 id="tcp拥塞控制" tabindex="-1"><a class="header-anchor" href="#tcp拥塞控制"><span>TCP拥塞控制</span></a></h3><p>拥塞控制（Congestion Control）：是一种用于防止网络过载并确保高效数据传输的机制。随着互联网规模和复杂性的增长，如何有效地管理网络资源成为了一个关键问题。TCP拥塞控制通过一系列算法来动态调整发送方的数据发送速率，以适应当前网络状况，避免因过多的数据包导致网络拥塞。</p><p>拥塞控制的目标</p><ul><li><strong>提高吞吐量</strong>：最大化利用可用带宽。</li><li><strong>减少延迟</strong>：尽量减小数据包在网络中的排队时间。</li><li><strong>公平性</strong>：保证多个流共享同一链路时能够公平地分配带宽。</li></ul><hr><div class="hint-container info"><p class="hint-container-title">主要的拥塞控制算法</p><ol><li><p><strong>慢启动（Slow Start）</strong></p><ul><li>在连接建立或超时后开始，初始拥塞窗口（cwnd, Congestion Window）设为较小值（通常是一个最大段大小MSS）。</li><li>发送方每收到一个ACK确认，就将cwnd增加一个MSS的大小，即指数增长。</li><li>当cwnd达到慢启动阈值（ssthresh）或者出现丢包时，进入拥塞避免阶段。</li></ul></li><li><p><strong>拥塞避免（Congestion Avoidance）</strong></p><ul><li>一旦cwnd达到ssthresh，便进入这个阶段。</li><li>相比于慢启动的指数增长，拥塞避免阶段cwnd的增长速度较慢，每经过一个往返时间RTT才增加一个MSS的大小。</li><li>如果检测到丢包，则会降低ssthresh，并根据具体策略调整cwnd大小。</li></ul></li><li><p><strong>快速重传（Fast Retransmit）</strong></p><ul><li>当发送方连续收到三个对相同未确认数据段的重复ACK时，认为该段丢失，无需等待重传计时器到期即可立即重传丢失的数据段。</li></ul></li><li><p><strong>快速恢复（Fast Recovery）</strong></p><ul><li>在快速重传之后，不执行慢启动而是直接进入拥塞避免阶段，避免了效率低下的重新开始慢启动过程。</li><li>快速恢复通过维持较高的cwnd值，同时基于接收到的重复ACK进行适当调整，帮助快速恢复至正常状态。</li></ul></li></ol></div><hr><p>其他改进和技术</p><ul><li><strong>选择性确认（Selective Acknowledgment, SACK）</strong>：允许接收方告知发送方哪些数据段已成功接收，使得发送方只需重传丢失的数据段而非所有后续数据段。</li><li><strong>TCP窗口缩放选项</strong>：为了支持更大数据量的传输，尤其是对于高带宽延迟积的产品，允许使用更大的窗口尺寸。</li><li><strong>ECN（显式拥塞通知）</strong>：一种让路由器在不丢弃数据包的情况下向发送方指示网络拥塞的方法，有助于更平滑地调整发送速率。</li></ul><hr><h2 id="user-datagram-protocol" tabindex="-1"><a class="header-anchor" href="#user-datagram-protocol"><span>User Datagram Protocol</span></a></h2><p>UDP（User Datagram Protocol，用户数据报协议）是一种无连接的、不可靠的传输层协议。</p><ol><li><strong>无连接</strong>：UDP不建立连接，直接发送数据报，减少了握手过程带来的延迟。</li><li><strong>不可靠传输</strong>：没有确认机制、重传机制或流量控制，可能导致数据丢失、重复或乱序。</li><li><strong>快速高效</strong>：由于缺少复杂的控制机制，UDP头小且处理速度快，适合需要低延迟的应用。</li><li><strong>支持广播和多播</strong>：能够向多个目的地发送单个数据报，适用于特定的网络应用。</li></ol><p>与TCP相比，UDP不提供连接管理、数据重传或排序等功能，但它具有较低的开销和较高的效率，适用于对实时性要求较高但对少量丢包不太敏感的应用场景，如视频流、语音通话、DNS查询等。</p><hr><h3 id="udp数据报格式" tabindex="-1"><a class="header-anchor" href="#udp数据报格式"><span>UDP数据报格式</span></a></h3><p>一个UDP数据报由两部分组成：<strong>头部（Header）<strong>和</strong>数据（Data）</strong>。UDP头部非常简单，固定8个字节（64位），这使得它比TCP更轻量级</p><figure><img src="https://image.ventix.top/img02/20220211171658238.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li><p><span style="color:orange;">源端口号（Source Port, 16 bits）</span>：标识发送该UDP数据报的应用程序端口。在客户端发起请求时会使用随机分配的高编号端口。</p></li><li><p><span style="color:orange;">目标端口号（Destination Port, 16 bits）</span>：标识接收方的应用程序端口号</p></li><li><p><span style="color:orange;">长度（Length, 16 bits）</span>：整个UDP数据报的长度，包括头部和数据部分。最小值为8（仅包含头部），最大值受限于IPv4或IPv6的最大传输单元（MTU）。</p></li><li><p><span style="color:orange;">校验和（Checksum, 16 bits）</span>：用于验证数据报的完整性和准确性</p></li></ol><hr><p>使用场景示例</p><ul><li><strong>实时音视频传输</strong>：如VoIP电话、在线直播等，对延迟敏感，少量数据丢失不会严重影响用户体验。</li><li><strong>域名系统（DNS）</strong>：查询请求短且频繁，UDP提供了足够的速度和效率。</li><li><strong>游戏服务器通信</strong>：快速响应的游戏互动，偶尔的数据丢失可通过游戏逻辑弥补。</li></ul><p>尽管UDP不具备TCP那样的可靠性，但其简洁的设计使其成为许多高性能、实时应用的理想选择</p><hr><h3 id="udp伪首部和校验和" tabindex="-1"><a class="header-anchor" href="#udp伪首部和校验和"><span>UDP伪首部和校验和</span></a></h3><p>伪首部是计算 <span style="color:#1E90FF;">UDP校验和</span> 时临时构造的一个数据结构，用于增强校验和的可靠性。</p><ul><li><span style="color:purple;">伪首部仅在 校验和 计算时使用，不会出现在实际的IP数据报或UDP数据报中</span></li><li>伪首部的构造和校验和的计算由操作系统的网络协议栈完成，应用程序无需直接处理</li></ul><p>伪首部由以下字段组成，共12字节：</p><figure><img src="https://image.ventix.top/img02/20220211171710524.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li><strong>Source IP Address（源IP地址）</strong>： 32位，表示IP数据报的源IP地址</li><li><strong>Destination IP Address（目标IP地址）</strong>： 32位，表示IP数据报的目标IP地址</li><li><strong>Zero（保留字段）</strong>： 8位，必须为 <code>0</code></li><li><strong>Protocol（协议类型）</strong>： 8位，表示上层协议类型（UDP的协议号为<code>17</code>）</li><li><strong>UDP Length（UDP长度）</strong>：16位，表示UDP数据报的总长度（包括首部和数据）</li></ol><hr><div class="hint-container info"><p class="hint-container-title">伪首部和校验和的工作流程</p><p><span style="color:#1E90FF;"><strong>发送端流程</strong></span>：</p><ol><li>构造伪首部：操作系统根据IP层提供的源IP地址、目标IP地址等信息构造伪首部。</li><li>计算校验和： <ul><li>将伪首部、UDP首部和UDP数据拼接成一个临时数据块。</li><li>对临时数据块按16位为单位进行反码求和，结果取反作为校验和。</li><li>将校验和存入UDP首部的校验和字段。</li></ul></li><li>封装并发送： 丢弃伪首部，将UDP首部和数据封装进IP数据报，通过网络层发送。</li></ol><hr><p><span style="color:#1E90FF;"><strong>接收端流程</strong></span>：</p><ol><li>提取数据报： 网络层接收到IP数据报，解封装后提取出UDP首部和数据部分</li><li>重构伪首部： 根据接收到的IP数据报中的源IP地址、目标IP地址等信息，重新构造伪首部</li><li><strong>验证校验和</strong>： <ul><li>将伪首部、UDP首部和数据拼接成一个临时数据块</li><li>对临时数据块按16位为单位进行反码求和</li><li>如果计算结果为全1（即<code>0xFFFF</code>），则校验和正确；否则，数据报被丢弃</li></ul></li></ol></div><p>伪首部中的源IP地址和目标IP地址从IP数据报的IP首部中提取。协议类型和UDP长度由操作系统根据具体情况确定。伪首部不是IP数据报的一部分，网络层只处理实际的IP数据报传输</p><hr>',41))])}const m=o(a,[["render",c],["__file","transport.html.vue"]]),k=JSON.parse('{"path":"/theory/cs/transport.html","title":"传输层（Transport Layer）","lang":"en-US","frontmatter":{"order":20,"title":"传输层（Transport Layer）","shortTitle":"传输层","description":"传输层（Transport Layer）：通过 端口机制 和 端到端逻辑信道，实现了真正意义上的进程间通信。传输层协议仅在网络边缘的主机中实现，路由器、交换机等网络核心设备仅处理下三层（网络层、数据链路层、物理层） TCP：提供面向连接、可靠的服务（如数据重传、流量控制） UDP：提供无连接、尽力而为的服务（适用于实时视频等低延迟场景） 运输层通过端口...","head":[["meta",{"property":"og:url","content":"https://x.app/theory/cs/transport.html"}],["meta",{"property":"og:site_name","content":"doc"}],["meta",{"property":"og:title","content":"传输层（Transport Layer）"}],["meta",{"property":"og:description","content":"传输层（Transport Layer）：通过 端口机制 和 端到端逻辑信道，实现了真正意义上的进程间通信。传输层协议仅在网络边缘的主机中实现，路由器、交换机等网络核心设备仅处理下三层（网络层、数据链路层、物理层） TCP：提供面向连接、可靠的服务（如数据重传、流量控制） UDP：提供无连接、尽力而为的服务（适用于实时视频等低延迟场景） 运输层通过端口..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://image.ventix.top/img02/20220210151434121.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-02-12T09:46:27.000Z"}],["meta",{"property":"article:author","content":"ventixy"}],["meta",{"property":"article:modified_time","content":"2025-02-12T09:46:27.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"传输层（Transport Layer）\\",\\"image\\":[\\"https://image.ventix.top/img02/20220210151434121.png\\",\\"https://image.ventix.top/img02/20230210190206103.png\\",\\"https://image.ventix.top/img02/20230210232822520.png\\",\\"https://image.ventix.top/img02/20230212153639272.png\\",\\"https://image.ventix.top/img02/20220211171658238.png\\",\\"https://image.ventix.top/img02/20220211171710524.png\\"],\\"dateModified\\":\\"2025-02-12T09:46:27.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ventixy\\",\\"url\\":\\"https://www.ventix.top\\"}]}"]]},"headers":[{"level":2,"title":"Transmission Control","slug":"transmission-control","link":"#transmission-control","children":[{"level":3,"title":"TCP协议数据报","slug":"tcp协议数据报","link":"#tcp协议数据报","children":[]},{"level":3,"title":"TCP连接的建立","slug":"tcp连接的建立","link":"#tcp连接的建立","children":[]},{"level":3,"title":"TCP连接的终止","slug":"tcp连接的终止","link":"#tcp连接的终止","children":[]},{"level":3,"title":"MSS和MTU","slug":"mss和mtu","link":"#mss和mtu","children":[]},{"level":3,"title":"TCP重传机制","slug":"tcp重传机制","link":"#tcp重传机制","children":[]},{"level":3,"title":"Sliding Window","slug":"sliding-window","link":"#sliding-window","children":[]},{"level":3,"title":"Flow Control","slug":"flow-control","link":"#flow-control","children":[]},{"level":3,"title":"TCP拥塞控制","slug":"tcp拥塞控制","link":"#tcp拥塞控制","children":[]}]},{"level":2,"title":"User Datagram Protocol","slug":"user-datagram-protocol","link":"#user-datagram-protocol","children":[{"level":3,"title":"UDP数据报格式","slug":"udp数据报格式","link":"#udp数据报格式","children":[]},{"level":3,"title":"UDP伪首部和校验和","slug":"udp伪首部和校验和","link":"#udp伪首部和校验和","children":[]}]}],"git":{"createdTime":1738853005000,"updatedTime":1739353587000,"contributors":[{"name":"drizzle","email":"msdrizzle@outlook.com","commits":2}]},"readingTime":{"minutes":23.71,"words":7114},"filePathRelative":"theory/cs/transport.md","localizedDate":"February 6, 2025","excerpt":"<p>传输层（Transport Layer）：通过 <mark>端口机制</mark> 和 <strong>端到端逻辑信道</strong>，实现了真正意义上的进程间通信。传输层协议仅在网络边缘的主机中实现，路由器、交换机等网络核心设备仅处理下三层（网络层、数据链路层、物理层）</p>\\n<ul>\\n<li>TCP：提供面向连接、可靠的服务（如数据重传、流量控制）</li>\\n<li>UDP：提供无连接、尽力而为的服务（适用于实时视频等低延迟场景）</li>\\n</ul>\\n<p>运输层通过端口号标识进程，使数据能够准确交付给目标应用（如HTTP默认端口80）</p>\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">端口号分类</p>\\n<ol>\\n<li>\\n<p><strong>知名端口（Well-Known Ports）</strong>：<code>0-1023</code>， 这些端口通常被分配给系统级的服务和应用程序，如HTTP (80), HTTPS (443), FTP (21), SSH (22)等。</p>\\n</li>\\n<li>\\n<p><strong>注册端口（Registered Ports）</strong>：<code>1024-49151</code>，可以由用户进程或应用程序动态选择，但通常用于特定的应用程序或服务，这些应用需要向IANA（互联网号码分配机构）注册以避免冲突</p>\\n</li>\\n<li>\\n<p><strong>动态/私有端口（Dynamic/Private Ports）</strong>：<code>49152-65535</code>，通常用于临时连接，当客户端发起请求时，操作系统会自动为该连接分配一个未使用的端口号。</p>\\n</li>\\n</ol>\\n</div>","autoDesc":true}');export{m as comp,k as data};
