import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,d as n,o as e}from"./app-Dr5PyE4U.js";const o={};function r(s,i){return e(),t("div",null,i[0]||(i[0]=[n('<h2 id="内存管理基础" tabindex="-1"><a class="header-anchor" href="#内存管理基础"><span>内存管理基础</span></a></h2><div class="hint-container info"><p class="hint-container-title">内存管理的主要功能</p><ol><li><strong>内存分配</strong>：为进程分配内存空间</li><li><strong>内存回收</strong>：回收进程释放的内存空间</li><li><strong>地址转换</strong>：逻辑地址到物理地址的映射</li><li><strong>内存保护</strong>：确保进程只能访问自己的内存空间</li><li><strong>内存共享</strong>：允许多个进程共享同一块内存</li></ol></div><h3 id="内存分配策略" tabindex="-1"><a class="header-anchor" href="#内存分配策略"><span>内存分配策略</span></a></h3><div class="hint-container tip"><p class="hint-container-title">主要的内存分配算法</p><ol><li><p><strong>首次适应（First Fit）</strong></p><ul><li>分配第一个足够大的空闲分区</li><li>实现简单，效率较高</li></ul></li><li><p><strong>最佳适应（Best Fit）</strong></p><ul><li>分配最小的足够大的空闲分区</li><li>空间利用率高，但查找时间长</li></ul></li><li><p><strong>最坏适应（Worst Fit）</strong></p><ul><li>分配最大的空闲分区</li><li>避免产生太多小碎片</li></ul></li><li><p><strong>伙伴系统</strong></p><ul><li>基于2的幂进行分配</li><li>便于合并，减少外部碎片</li></ul></li></ol></div><h3 id="地址转换" tabindex="-1"><a class="header-anchor" href="#地址转换"><span>地址转换</span></a></h3><div class="hint-container info"><p class="hint-container-title">地址转换机制</p><ol><li><p><strong>逻辑地址</strong></p><ul><li>程序产生的地址</li><li>相对地址，从0开始</li></ul></li><li><p><strong>物理地址</strong></p><ul><li>实际的内存地址</li><li>通过地址映射转换得到</li></ul></li><li><p><strong>地址绑定</strong></p><ul><li>编译时绑定</li><li>加载时绑定</li><li>运行时绑定</li></ul></li></ol></div><h3 id="内存保护" tabindex="-1"><a class="header-anchor" href="#内存保护"><span>内存保护</span></a></h3><div class="hint-container tip"><p class="hint-container-title">内存保护机制</p><ol><li><p><strong>界限寄存器</strong></p><ul><li>存储进程的上下界地址</li><li>防止越界访问</li></ul></li><li><p><strong>访问权限控制</strong></p><ul><li>读/写/执行权限</li><li>页表项中的保护位</li></ul></li><li><p><strong>段保护</strong></p><ul><li>段级别的访问控制</li><li>支持共享和保护</li></ul></li></ol></div><h2 id="虚拟内存" tabindex="-1"><a class="header-anchor" href="#虚拟内存"><span>虚拟内存</span></a></h2><div class="hint-container info"><p class="hint-container-title">虚拟内存的基本概念</p><ul><li><p><strong>定义</strong>：将物理内存和外存结合，提供更大的地址空间</p></li><li><p><strong>优点</strong>：</p><ol><li>提供更大的地址空间</li><li>实现进程隔离</li><li>支持共享内存</li><li>提高内存利用率</li></ol></li><li><p><strong>实现方式</strong>：</p><ol><li>请求分页</li><li>请求分段</li><li>段页式</li></ol></li></ul></div><h3 id="页面置换算法" tabindex="-1"><a class="header-anchor" href="#页面置换算法"><span>页面置换算法</span></a></h3><div class="hint-container tip"><p class="hint-container-title">常见的页面置换算法</p><ol><li><p><strong>最优算法（OPT）</strong></p><ul><li>理论最优，实际无法实现</li><li>替换最长时间内不会被访问的页面</li></ul></li><li><p><strong>先进先出（FIFO）</strong></p><ul><li>替换最先进入的页面</li><li>实现简单，但性能不佳</li></ul></li><li><p><strong>最近最少使用（LRU）</strong></p><ul><li>替换最长时间未被访问的页面</li><li>性能好但实现复杂</li></ul></li><li><p><strong>时钟算法（Clock）</strong></p><ul><li>LRU的近似实现</li><li>使用循环队列和使用位</li></ul></li></ol></div><h3 id="工作集" tabindex="-1"><a class="header-anchor" href="#工作集"><span>工作集</span></a></h3><div class="hint-container info"><p class="hint-container-title">工作集管理</p><ul><li><strong>工作集</strong>：进程在一段时间内实际访问的页面集合</li><li><strong>工作集窗口</strong>：用于确定工作集的时间范围</li><li><strong>页面调度</strong>：根据工作集进行内存分配和回收</li><li><strong>抖动问题</strong>：进程频繁换入换出页面的现象</li></ul></div>',14)]))}const c=l(o,[["render",r],["__file","memory.html.vue"]]),g=JSON.parse('{"path":"/theory/cs/memory.html","title":"内存管理","lang":"en-US","frontmatter":{"order":70,"title":"内存管理","description":"内存管理基础 内存管理的主要功能 内存分配：为进程分配内存空间 内存回收：回收进程释放的内存空间 地址转换：逻辑地址到物理地址的映射 内存保护：确保进程只能访问自己的内存空间 内存共享：允许多个进程共享同一块内存 内存分配策略 主要的内存分配算法 首次适应（First Fit） 分配第一个足够大的空闲分区 实现简单，效率较高 最佳适应（Best Fit...","head":[["meta",{"property":"og:url","content":"https://x.app/theory/cs/memory.html"}],["meta",{"property":"og:site_name","content":"doc"}],["meta",{"property":"og:title","content":"内存管理"}],["meta",{"property":"og:description","content":"内存管理基础 内存管理的主要功能 内存分配：为进程分配内存空间 内存回收：回收进程释放的内存空间 地址转换：逻辑地址到物理地址的映射 内存保护：确保进程只能访问自己的内存空间 内存共享：允许多个进程共享同一块内存 内存分配策略 主要的内存分配算法 首次适应（First Fit） 分配第一个足够大的空闲分区 实现简单，效率较高 最佳适应（Best Fit..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-03-13T01:07:22.000Z"}],["meta",{"property":"article:author","content":"ventixy"}],["meta",{"property":"article:modified_time","content":"2025-03-13T01:07:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"内存管理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-13T01:07:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ventixy\\",\\"url\\":\\"https://www.ventix.top\\"}]}"]]},"headers":[{"level":2,"title":"内存管理基础","slug":"内存管理基础","link":"#内存管理基础","children":[{"level":3,"title":"内存分配策略","slug":"内存分配策略","link":"#内存分配策略","children":[]},{"level":3,"title":"地址转换","slug":"地址转换","link":"#地址转换","children":[]},{"level":3,"title":"内存保护","slug":"内存保护","link":"#内存保护","children":[]}]},{"level":2,"title":"虚拟内存","slug":"虚拟内存","link":"#虚拟内存","children":[{"level":3,"title":"页面置换算法","slug":"页面置换算法","link":"#页面置换算法","children":[]},{"level":3,"title":"工作集","slug":"工作集","link":"#工作集","children":[]}]}],"git":{"createdTime":1741828042000,"updatedTime":1741828042000,"contributors":[{"name":"drizzle","email":"msdrizzle@outlook.com","commits":1}]},"readingTime":{"minutes":2.24,"words":671},"filePathRelative":"theory/cs/memory.md","localizedDate":"March 13, 2025","excerpt":"<h2>内存管理基础</h2>\\n<div class=\\"hint-container info\\">\\n<p class=\\"hint-container-title\\">内存管理的主要功能</p>\\n<ol>\\n<li><strong>内存分配</strong>：为进程分配内存空间</li>\\n<li><strong>内存回收</strong>：回收进程释放的内存空间</li>\\n<li><strong>地址转换</strong>：逻辑地址到物理地址的映射</li>\\n<li><strong>内存保护</strong>：确保进程只能访问自己的内存空间</li>\\n<li><strong>内存共享</strong>：允许多个进程共享同一块内存</li>\\n</ol>\\n</div>","autoDesc":true}');export{c as comp,g as data};
