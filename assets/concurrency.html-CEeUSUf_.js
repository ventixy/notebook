import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,b as l,a as i,e,d as s,w as t,r as h,o as d}from"./app-DROnWr0m.js";const c={},p={class:"hint-container info"};function k(u,a){const n=h("RouteLink");return d(),o("div",null,[a[7]||(a[7]=l(`<h2 id="java并发编程基础" tabindex="-1"><a class="header-anchor" href="#java并发编程基础"><span>Java并发编程基础</span></a></h2><p>并发和并行有什么区别</p><ul><li>并发是指两个或多个任务在同一时间段内开始、执行和完成，但不意味着它们在物理上同时执行。</li><li>并行则是指两个或多个任务在同一时刻真正同时执行。</li></ul><p>什么是线程和进程？有什么区别？</p><ul><li>进程是操作系统进行资源分配和调度的基本单位, 进程是一个独立的执行环境，拥有独立的内存空间、系统资源</li><li>线程是进程内的一个执行单元，是CPU调度的基本单位</li></ul><h3 id="线程的创建" tabindex="-1"><a class="header-anchor" href="#线程的创建"><span>线程的创建</span></a></h3><p>创建线程：继承Thread，实现Runnable，实现Callable</p><p>Callable规定的方法是call()，而Runnable规定的方法是run()。Callable的任务执行后可返回值，可拿到一个Future对象。</p><p>注意 start 和 run</p><ul><li>run方法根本就没有开辟新的执行路径,还是按照顺序执行的，直接调用run方法,相当于普通成员方法调用</li><li>start方法才是真正的去创建线程。但只有run方法当中的代码才会执行在子线程中,我们要把我们的代码写到run方法中,并且启动的时候一定是start方法</li></ul><h3 id="线程的生命周期" tabindex="-1"><a class="header-anchor" href="#线程的生命周期"><span>线程的生命周期</span></a></h3><p>Thread.State是一个内部枚举类，定义了6个枚举常量，分别代表Java线程的6种状态：<br> New（新建），Runnable（可运行）, Blocked（阻塞），Waiting（等待），Timed Waiting（超时等待），Terminated（终止）</p><p>Runnable合并了操作系统层面的就绪（ready）和运行（running）状态</p><p>操作系统的线程状态：New（新建）， Ready（可运行/就绪），Running（运行），Blocked（阻塞），Dead（死亡）</p><h3 id="线程通信方式" tabindex="-1"><a class="header-anchor" href="#线程通信方式"><span>线程通信方式</span></a></h3><p>Object的等待/通知机制 是基于对象监视器（Monitor）的一种线程间通信方式，主要通过wait(), notify(), 和 notifyAll()这三个方法来实现：</p><ul><li>wait()方法使当前线程进入等待（WAITING）状态，并释放它所持有的对象的监视器锁</li><li>notify()方法随机唤醒在此对象监视器上等待的一个线程。</li><li>notifyAll()方法唤醒在此对象监视器上等待的所有线程。</li></ul><p>Condition常用方法：<br> await(): 使当前线程等待 signal(): 唤醒在此Condition上等待的一个线程 signalAll(): 唤醒在此Condition上等待的所有线程。</p><h3 id="线程死锁" tabindex="-1"><a class="header-anchor" href="#线程死锁"><span>线程死锁</span></a></h3><p>什么是线程死锁？如何避免死锁？</p><p>线程死锁：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>例如：线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p>如何预防死锁？ 破坏死锁的产生的必要条件即可：</p><ol><li>破坏请求与保持条件 ：一次性申请所有的资源。</li><li>破坏不剥夺条件 ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li>破坏循环等待条件 ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol><p>如何避免死锁？<br> 避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p><h3 id="线程池种类和参数" tabindex="-1"><a class="header-anchor" href="#线程池种类和参数"><span>线程池种类和参数</span></a></h3><p><strong>线程池</strong>：预先创建一组线程，复用这些线程处理任务，减少线程创建和销毁的开销。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ThreadPoolExecutor</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> executor </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ThreadPoolExecutor</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">    10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 核心线程数</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">    20</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 最大线程数</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">    60</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 非核心线程闲置超时时间，单位为秒</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    TimeUnit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">SECONDS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 时间单位</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> LinkedBlockingQueue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 任务队列，容量100</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    Executors</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">defaultThreadFactory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(),</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 使用默认线程工厂</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    new</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> ThreadPoolExecutor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">AbortPolicy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 拒绝策略为抛出异常</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如何合理地设置 Java 线程池的线程数？</p><ul><li>一般设置为 <code>CPU 核心数 + 1</code> 或 <code>CPU 核心数 * 2</code>，具体取决于任务类型和系统负载。</li></ul><p>Java 线程池有哪些拒绝策略？</p><ul><li><strong>AbortPolicy</strong>：抛出 <code>RejectedExecutionException</code>。</li><li><strong>CallerRunsPolicy</strong>：由调用线程执行任务。</li><li><strong>DiscardPolicy</strong>：丢弃任务。</li><li><strong>DiscardOldestPolicy</strong>：丢弃队列中最老的任务，再提交新任务。</li></ul><p>Java 并发库中提供了哪些线程池实现？它们有什么区别？</p><ul><li><strong>FixedThreadPool</strong>：固定大小的线程池。</li><li><strong>CachedThreadPool</strong>：可缓存的线程池，适合执行大量短小任务。</li><li><strong>SingleThreadExecutor</strong>：单线程的线程池。</li><li><strong>ScheduledThreadPool</strong>：支持定时和周期任务的线程池。</li></ul><p>Java 线程池核心线程数在运行过程中能修改吗？如何修改？</p><ul><li>可以通过 <code>setCorePoolSize(int corePoolSize)</code> 方法修改核心线程数。</li></ul><p>Java 线程池中 shutdown 与 shutdownNow 的区别是什么？</p><ul><li><strong><code>shutdown()</code></strong>：停止接收新任务，等待已提交任务执行完毕。</li><li><strong><code>shutdownNow()</code></strong>：尝试停止所有活动任务，并返回未执行的任务列表。</li></ul>`,38)),i("div",p,[a[4]||(a[4]=i("p",{class:"hint-container-title"},"ForkJoinPool",-1)),i("p",null,[a[1]||(a[1]=e("ForkJoinPool是Fork/Join框架的核心执行器，它是一个特殊的线程池，用于管理和调度任务。它使用了")),a[2]||(a[2]=i("mark",null,"工作窃取（Work-Stealing）算法",-1)),a[3]||(a[3]=e("，这意味着当一个线程完成其分配的任务并且没有更多任务可执行时，它会尝试“窃取”其他线程的任务，从而提高CPU利用率。 具体使用方法参照：")),s(n,{to:"/java/syntax/thread/pool.html#%E4%BD%BF%E7%94%A8%E5%8F%8A%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"},{default:t(()=>a[0]||(a[0]=[e("ForkJoinPool使用示例")])),_:1})])]),a[8]||(a[8]=l('<h3 id="synchronized" tabindex="-1"><a class="header-anchor" href="#synchronized"><span>synchronized</span></a></h3><p>synchronized 的本质是通过 监视器锁（Monitor） 来实现对共享资源的访问控制。它可以通过两种形式使用：同步方法和同步代码块。</p><p>synchronized的底层实现与Java对象头的<code>Mark Word</code>紧密相关</p><div class="hint-container info"><p class="hint-container-title">synchronized锁的升级</p><ul><li>偏向锁: 当一个线程第一次获取锁时， 会将该线程标记为“偏向”状态，后续若该线程再获取该锁，几乎没有开销,。</li><li>轻量级锁: 当另一个线程尝试获取已经被偏向的锁时，锁会升级为轻量级锁，使用CAS 操作来减少锁竞争的开销。</li><li>重量级锁: 当 CAS 失败无法获取锁，锁会升级为重量级锁，线程会被挂起，直到锁被释放。</li></ul></div><h3 id="locks-lock" tabindex="-1"><a class="header-anchor" href="#locks-lock"><span>Locks.Lock</span></a></h3><p>与synchronized的区别：Lock提供了更多的控制权，比如尝试获取锁、定时获取锁、可中断的锁等待等。Lock支持中断等待锁的线程，而synchronized不支持。使用Lock需要更仔细地管理锁的获取和释放。synchronized的有一个锁升级的过程，实测两者性能差异不大。</p><div class="hint-container info"><p class="hint-container-title">Lock接口</p><h4 id="reentrantlock-可重入锁" tabindex="-1"><a class="header-anchor" href="#reentrantlock-可重入锁"><span>ReentrantLock（可重入锁）</span></a></h4><p>最常用的Lock实现之一，支持公平和非公平策略。</p><p>ReentrantLock 其实就是基于 AQS 实现的一个可重入锁，支持公平和非公平两种方式<br> 内部实现依靠一个 state 变量和两个等待队列:同步队列和等待队列。<br> 利用 CAS 修改 state 来争抢锁。<br> 争抢不到则入同步队列等待，同步队列是一个双向链表。<br> 条件 condition 不满足时候则入等待队列等待，是个单向链表。<br> 是否是公平锁的区别在于: 线程获取锁时是加入到同步队列尾部还是直接利用 CAS 争抢锁。</p><h4 id="reentrantreadwritelock" tabindex="-1"><a class="header-anchor" href="#reentrantreadwritelock"><span>ReentrantReadWriteLock</span></a></h4><p>读写锁，分为读锁和写锁。允许多个读线程同时访问，但在写线程访问时会独占锁，即读写互斥，写写互斥，但读读不互斥，适合读多写少的场景。</p><h4 id="stampedlock" tabindex="-1"><a class="header-anchor" href="#stampedlock"><span>StampedLock</span></a></h4><p>一种更高级的锁，提供了乐观读锁、悲观读锁、写锁以及尝试转换锁状态的能力，使用“邮票”（stamp）来标识锁状态。</p></div><h2 id="aqs及相关工具" tabindex="-1"><a class="header-anchor" href="#aqs及相关工具"><span>AQS及相关工具</span></a></h2><p>底层使用到AQS的并发工具:</p><p>ReentrantLock：可重入独占锁。<br> ReentrantReadWriteLock：读写锁，支持更细粒度的并发控制。<br> FutureTask 和 Phaser 等其他高级同步组件。</p><h3 id="semaphore" tabindex="-1"><a class="header-anchor" href="#semaphore"><span>Semaphore</span></a></h3><p>控制同时访问特定资源的线程数。</p><h3 id="countdownlatch" tabindex="-1"><a class="header-anchor" href="#countdownlatch"><span>CountDownLatch</span></a></h3><p>允许一个或多个线程等待其他线程完成操作。</p><h3 id="cyclicbarrier" tabindex="-1"><a class="header-anchor" href="#cyclicbarrier"><span>CyclicBarrier</span></a></h3><p>让一组线程等待所有线程到达某个屏障后再一起执行。</p><h2 id="高级并发工具及原理" tabindex="-1"><a class="header-anchor" href="#高级并发工具及原理"><span>高级并发工具及原理</span></a></h2><ul><li><strong><code>CountDownLatch</code></strong>：倒计数锁，等待多个线程完成。</li><li><strong><code>CyclicBarrier</code></strong>：循环屏障，等待多个线程到达一个屏障点。</li><li><strong><code>Semaphore</code></strong>：信号量，控制同时访问特定资源的线程数量。</li></ul><h3 id="volatile" tabindex="-1"><a class="header-anchor" href="#volatile"><span>volatile</span></a></h3><p>volatile是Java中的一个关键字，主要用于修饰变量。它有两个主要作用：</p><ul><li><p>保证可见性：当一个变量被声明为volatile时，任何线程对它的修改都会立即写入主内存，而其它线程对这个变量的读取也会直接从主内存中读取最新的值。这确保了多线程环境下变量值的可见性。</p></li><li><p>禁止指令重排序：在JVM中，为了优化性能，编译器和处理器可能会对指令进行重排序。volatile关键字能禁止某些类型的指令重排序，以保证有序性，尤其是对单个变量的读/写操作不会被重排序。</p></li></ul><h3 id="completablefuture" tabindex="-1"><a class="header-anchor" href="#completablefuture"><span>CompletableFuture</span></a></h3><p>CompletableFuture是对Future的改进，对于真正的异步处理我们希望是可以通过传入回调函数，在Future结束时自动调用该回调函数，这样，我们就不用等待结果</p><p>get()方法在Future计算完成之前会一直处在阻塞状态下，阻塞的方式和异步编程的设计理念相违背。isDone()方法容易耗费cpu资源（cpu空转）</p><ul><li>默认情况下，CompletableFuture 使用 ForkJoinPool.commonPool() 作为执行器，用户也可以指定自定义的线程池。</li><li>利用了 LockSupport.park/unpark 和 CAS 操作实现高效的线程同步，减少不必要的阻塞等待。</li></ul>',25)),i("p",null,[a[6]||(a[6]=e("具体使用方式参照：")),s(n,{to:"/java/syntax/thread/tool.html#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E7%A4%BA%E4%BE%8B-2"},{default:t(()=>a[5]||(a[5]=[e("CompletableFuture代码示例")])),_:1})]),a[9]||(a[9]=l('<h3 id="cas和原子类" tabindex="-1"><a class="header-anchor" href="#cas和原子类"><span>CAS和原子类</span></a></h3><p>CAS自旋（Compare-And-Swap）是一种在多线程环境下的非阻塞同步技术，主要用于实现轻量级的锁机制，比如自旋锁。</p><p>它的基本思想是在硬件层面提供一个原子操作，允许线程在没有获得锁时，不是立刻放弃CPU时间片进入等待状态（如挂起），而是自旋（Spin）一小段时间，反复尝试获取锁，直到成功或达到一定次数后再采取其他策略（如挂起）。.</p><p>这种机制特别适合于锁持有时间短且线程竞争不激烈的场景。</p><div class="hint-container info"><p class="hint-container-title">CAS &amp; ABA</p><h4 id="cas操作" tabindex="-1"><a class="header-anchor" href="#cas操作"><span>CAS操作</span></a></h4><p>CAS操作包含三个参数：内存位置（V）、预期原值（A）和新值(B)。具体流程如下：</p><ul><li>比较：首先，它会比较内存位置V的值是否等于预期原值A。</li><li>交换：如果相等，就将内存位置V的值更新为新值B，并返回true，表示更新成功。</li><li>失败则重试：如果不相等，说明其他线程已经修改了内存位置V的值，此时不进行任何操作，返回false。然后，执行CAS的线程可以选择重新尝试整个操作，这就是所谓的“自旋”。</li></ul><h4 id="aba问题" tabindex="-1"><a class="header-anchor" href="#aba问题"><span>ABA问题</span></a></h4><p>CAS操作可能会遇到ABA问题，即内存位置的值从A变为B再变回A，但实际发生了变化。为解决这个问题，通常会配合版本号或者使用带有标记的引用（如AtomicStampedReference）。</p></div><ul><li><strong><code>AtomicInteger</code></strong>：原子整数。</li><li><strong><code>AtomicLong</code></strong>：原子长整数。</li><li><strong><code>AtomicBoolean</code></strong>：原子布尔值。</li><li><strong><code>AtomicReference</code></strong>：原子引用。</li></ul><h4 id="你使用过-java-的累加器吗" tabindex="-1"><a class="header-anchor" href="#你使用过-java-的累加器吗"><span>你使用过 Java 的累加器吗？</span></a></h4><ul><li><strong>累加器</strong>：如 <code>LongAdder</code> 和 <code>DoubleAdder</code>，用于高并发环境下的累加操作。</li></ul><h3 id="threadlocal" tabindex="-1"><a class="header-anchor" href="#threadlocal"><span>ThreadLocal</span></a></h3><h4 id="为什么在-java-中需要使用-threadlocal" tabindex="-1"><a class="header-anchor" href="#为什么在-java-中需要使用-threadlocal"><span>为什么在 Java 中需要使用 ThreadLocal？</span></a></h4><ul><li><strong>ThreadLocal</strong>：用于在每个线程中存储独立的副本，避免线程间的数据共享问题。</li></ul><h4 id="java-中的-threadlocal-是如何实现线程资源隔离的" tabindex="-1"><a class="header-anchor" href="#java-中的-threadlocal-是如何实现线程资源隔离的"><span>Java 中的 ThreadLocal 是如何实现线程资源隔离的？</span></a></h4><ul><li><strong>ThreadLocal</strong>：每个线程都有一个独立的 ThreadLocalMap，存储线程局部变量。</li></ul><h4 id="为什么-java-中的-threadlocal-对-key-的引用为弱引用" tabindex="-1"><a class="header-anchor" href="#为什么-java-中的-threadlocal-对-key-的引用为弱引用"><span>为什么 Java 中的 ThreadLocal 对 key 的引用为弱引用？</span></a></h4><ul><li><strong>弱引用</strong>：防止内存泄漏，当线程结束时，ThreadLocalMap 中的条目可以被垃圾回收。</li></ul><h4 id="java-中使用-threadlocal-的最佳实践是什么" tabindex="-1"><a class="header-anchor" href="#java-中使用-threadlocal-的最佳实践是什么"><span>Java 中使用 ThreadLocal 的最佳实践是什么？</span></a></h4><ul><li><strong>及时清理</strong>：使用 <code>remove</code> 方法及时清理不再使用的 ThreadLocal 变量。</li><li><strong>避免滥用</strong>：不要过度使用 ThreadLocal，以免增加内存开销。</li></ul><h4 id="java-中的-inheritablethreadlocal-是什么" tabindex="-1"><a class="header-anchor" href="#java-中的-inheritablethreadlocal-是什么"><span>Java 中的 InheritableThreadLocal 是什么？</span></a></h4><ul><li><strong>InheritableThreadLocal</strong>：子线程可以继承父线程的 ThreadLocal 变量值。</li></ul><h4 id="threadlocal-的缺点" tabindex="-1"><a class="header-anchor" href="#threadlocal-的缺点"><span>ThreadLocal 的缺点？</span></a></h4><ul><li><strong>内存泄漏</strong>：如果不及时清理，可能导致内存泄漏。</li><li><strong>滥用问题</strong>：过度使用可能导致代码难以理解和维护。</li></ul><h4 id="为什么-netty-不使用-threadlocal-而是自定义了一个-fastthreadlocal" tabindex="-1"><a class="header-anchor" href="#为什么-netty-不使用-threadlocal-而是自定义了一个-fastthreadlocal"><span>为什么 Netty 不使用 ThreadLocal 而是自定义了一个 FastThreadLocal ？</span></a></h4><ul><li><strong>性能优化</strong>：FastThreadLocal 通过减少内存开销和提高访问速度来优化性能。</li></ul><h4 id="什么是-java-的-transmittablethreadlocal" tabindex="-1"><a class="header-anchor" href="#什么是-java-的-transmittablethreadlocal"><span>什么是 Java 的 TransmittableThreadLocal？</span></a></h4><ul><li><strong>TransmittableThreadLocal</strong>：扩展了 ThreadLocal，支持在线程间传递线程局部变量，常用于异步调用场景。</li></ul>',25))])}const y=r(c,[["render",k],["__file","concurrency.html.vue"]]),v=JSON.parse('{"path":"/interview/java/concurrency.html","title":"Java并发编程","lang":"en-US","frontmatter":{"order":20,"title":"Java并发编程","description":"Java并发编程基础 并发和并行有什么区别 并发是指两个或多个任务在同一时间段内开始、执行和完成，但不意味着它们在物理上同时执行。 并行则是指两个或多个任务在同一时刻真正同时执行。 什么是线程和进程？有什么区别？ 进程是操作系统进行资源分配和调度的基本单位, 进程是一个独立的执行环境，拥有独立的内存空间、系统资源 线程是进程内的一个执行单元，是CPU调...","head":[["meta",{"property":"og:url","content":"https://x.app/interview/java/concurrency.html"}],["meta",{"property":"og:site_name","content":"doc"}],["meta",{"property":"og:title","content":"Java并发编程"}],["meta",{"property":"og:description","content":"Java并发编程基础 并发和并行有什么区别 并发是指两个或多个任务在同一时间段内开始、执行和完成，但不意味着它们在物理上同时执行。 并行则是指两个或多个任务在同一时刻真正同时执行。 什么是线程和进程？有什么区别？ 进程是操作系统进行资源分配和调度的基本单位, 进程是一个独立的执行环境，拥有独立的内存空间、系统资源 线程是进程内的一个执行单元，是CPU调..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-01-10T15:19:41.000Z"}],["meta",{"property":"article:author","content":"ventixy"}],["meta",{"property":"article:modified_time","content":"2025-01-10T15:19:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java并发编程\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-01-10T15:19:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ventixy\\",\\"url\\":\\"https://www.ventix.top\\"}]}"]]},"headers":[{"level":2,"title":"Java并发编程基础","slug":"java并发编程基础","link":"#java并发编程基础","children":[{"level":3,"title":"线程的创建","slug":"线程的创建","link":"#线程的创建","children":[]},{"level":3,"title":"线程的生命周期","slug":"线程的生命周期","link":"#线程的生命周期","children":[]},{"level":3,"title":"线程通信方式","slug":"线程通信方式","link":"#线程通信方式","children":[]},{"level":3,"title":"线程死锁","slug":"线程死锁","link":"#线程死锁","children":[]},{"level":3,"title":"线程池种类和参数","slug":"线程池种类和参数","link":"#线程池种类和参数","children":[]},{"level":3,"title":"synchronized","slug":"synchronized","link":"#synchronized","children":[]},{"level":3,"title":"Locks.Lock","slug":"locks-lock","link":"#locks-lock","children":[]}]},{"level":2,"title":"AQS及相关工具","slug":"aqs及相关工具","link":"#aqs及相关工具","children":[{"level":3,"title":"Semaphore","slug":"semaphore","link":"#semaphore","children":[]},{"level":3,"title":"CountDownLatch","slug":"countdownlatch","link":"#countdownlatch","children":[]},{"level":3,"title":"CyclicBarrier","slug":"cyclicbarrier","link":"#cyclicbarrier","children":[]}]},{"level":2,"title":"高级并发工具及原理","slug":"高级并发工具及原理","link":"#高级并发工具及原理","children":[{"level":3,"title":"volatile","slug":"volatile","link":"#volatile","children":[]},{"level":3,"title":"CompletableFuture","slug":"completablefuture","link":"#completablefuture","children":[]},{"level":3,"title":"CAS和原子类","slug":"cas和原子类","link":"#cas和原子类","children":[]},{"level":3,"title":"ThreadLocal","slug":"threadlocal","link":"#threadlocal","children":[]}]}],"git":{"createdTime":1736522381000,"updatedTime":1736522381000,"contributors":[{"name":"drizzle","email":"msdrizzle@outlook.com","commits":1}]},"readingTime":{"minutes":10.83,"words":3249},"filePathRelative":"interview/java/concurrency.md","localizedDate":"January 10, 2025","excerpt":"<h2>Java并发编程基础</h2>\\n<p>并发和并行有什么区别</p>\\n<ul>\\n<li>并发是指两个或多个任务在同一时间段内开始、执行和完成，但不意味着它们在物理上同时执行。</li>\\n<li>并行则是指两个或多个任务在同一时刻真正同时执行。</li>\\n</ul>\\n<p>什么是线程和进程？有什么区别？</p>\\n<ul>\\n<li>进程是操作系统进行资源分配和调度的基本单位, 进程是一个独立的执行环境，拥有独立的内存空间、系统资源</li>\\n<li>线程是进程内的一个执行单元，是CPU调度的基本单位</li>\\n</ul>\\n<h3>线程的创建</h3>\\n<p>创建线程：继承Thread，实现Runnable，实现Callable</p>","autoDesc":true}');export{y as comp,v as data};
