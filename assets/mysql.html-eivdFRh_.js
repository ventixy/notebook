import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,b as s,o as r}from"./app-CDk9dZVz.js";const i={};function t(e,l){return r(),o("div",null,l[0]||(l[0]=[s('<h2 id="mysql数据库基础" tabindex="-1"><a class="header-anchor" href="#mysql数据库基础"><span>MySQL数据库基础</span></a></h2><h3 id="基础及常见问题" tabindex="-1"><a class="header-anchor" href="#基础及常见问题"><span>基础及常见问题</span></a></h3><ul><li><p><strong>MySQL 中 EXISTS 和 IN 的区别是什么？</strong></p><ul><li><strong>EXISTS</strong>：通常用于检查子查询是否返回至少一行数据，返回布尔值（存在或不存在）。性能较好，特别是在子查询结果集较大的情况下。</li><li><strong>IN</strong>：用于检查某个值是否存在于子查询的结果集中，返回布尔值。适用于结果集较小的情况。</li></ul></li><li><p><strong>MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？</strong></p><ul><li><strong>count(*)</strong>：统计所有行数，包括 NULL 值。</li><li><strong>count(1)</strong>：等同于 <code>count(*)</code>，常用于提高可读性。</li><li><strong>count(字段名)</strong>：统计指定字段不为 NULL 的行数。</li></ul></li><li><p><strong>MySQL 中 INNER JOIN、LEFT JOIN 和 RIGHT JOIN 的区别是什么？</strong></p><ul><li><strong>INNER JOIN</strong>：返回两个表中匹配的行。</li><li><strong>LEFT JOIN</strong>：返回左表中的所有行，以及右表中匹配的行。如果右表中没有匹配的行，结果为 NULL。</li><li><strong>RIGHT JOIN</strong>：返回右表中的所有行，以及左表中匹配的行。如果左表中没有匹配的行，结果为 NULL。</li></ul></li><li><p><strong>MySQL 中 DELETE、DROP 和 TRUNCATE 的区别是什么？</strong></p><ul><li><strong>DELETE</strong>：删除表中的特定行，可以使用 WHERE 子句指定条件，操作日志记录。</li><li><strong>TRUNCATE</strong>：删除表中的所有行，不记录日志，速度快，但不能回滚。</li><li><strong>DROP</strong>：删除整个表，包括表结构，操作不可逆。</li></ul></li><li><p><strong>什么是数据库的逻辑删除？数据库的物理删除和逻辑删除有什么区别？</strong></p><ul><li><strong>逻辑删除</strong>：通过设置标志位（如 <code>is_deleted</code>）来标记记录已删除，实际数据仍保留在数据库中。</li><li><strong>物理删除</strong>：彻底删除记录，释放存储空间。</li><li><strong>区别</strong>：逻辑删除可以恢复数据，物理删除不可恢复，且释放存储空间。</li></ul></li><li><p><strong>在 MySQL 中，你使用过哪些函数？</strong></p><ul><li><strong>字符串函数</strong>：<code>LOWER()</code>、<code>UPPER()</code>、<code>CONCAT()</code>、<code>SUBSTRING()</code></li><li><strong>数值函数</strong>：<code>ABS()</code>、<code>CEIL()</code>、<code>FLOOR()</code>、<code>ROUND()</code></li><li><strong>日期函数</strong>：<code>NOW()</code>、<code>CURDATE()</code>、<code>CURTIME()</code>、<code>DATE_ADD()</code>、<code>DATE_SUB()</code></li><li><strong>聚合函数</strong>：<code>COUNT()</code>、<code>SUM()</code>、<code>AVG()</code>、<code>MAX()</code>、<code>MIN()</code></li></ul></li><li><p><strong>MySQL 中的数据排序是怎么实现的？</strong></p><ul><li><strong>命中索引</strong>：如果排序字段命中索引，MySQL 直接使用索引排序。</li><li><strong>文件排序（Filesort）</strong>：如果未命中索引，MySQL 使用文件排序算法进行排序。</li></ul></li><li><p><strong>MySQL 中 AUTO_INCREMENT 列达到最大值时会发生什么？</strong></p><ul><li><strong>错误</strong>：MySQL 会抛出错误 <code>Error 1062: Duplicate entry &#39;...&#39; for key &#39;PRIMARY&#39;</code>。</li><li><strong>解决方案</strong>：手动重置 AUTO_INCREMENT 值，或删除表后重建。</li></ul></li><li><p><strong>MySQL 中 <code>LIMIT 100000000, 10</code> 和 <code>LIMIT 10</code> 的执行速度是否相同？</strong></p><ul><li><strong>不同</strong>：<code>LIMIT 100000000, 10</code> 需要先跳过前 100000000 行，性能较差；<code>LIMIT 10</code> 只需要获取前 10 行，性能较好。</li></ul></li><li><p><strong>MySQL 中如何解决深度分页的问题？</strong></p><ul><li><strong>使用覆盖索引</strong>：减少回表操作。</li><li><strong>使用键值对存储</strong>：将分页数据预先存储在键值对中。</li><li><strong>使用临时表</strong>：将分页数据存储在临时表中，减少查询次数。</li></ul></li></ul><h3 id="其他问题" tabindex="-1"><a class="header-anchor" href="#其他问题"><span>其他问题</span></a></h3><ul><li><p><strong>什么是数据库的视图？</strong></p><ul><li>视图是一个虚拟表，基于 SQL 语句的结果集。视图不存储实际数据，而是存储查询逻辑。</li></ul></li><li><p><strong>什么是数据库的游标？</strong></p><ul><li>游标用于从数据库中逐行检索数据，通常用于处理大量数据或需要逐行处理的场景。</li></ul></li><li><p><strong>相比于 Oracle，MySQL 的优势有哪些？</strong></p><ul><li><strong>开源免费</strong>：MySQL 是开源软件，成本较低。</li><li><strong>轻量级</strong>：MySQL 资源占用较少，启动速度快。</li><li><strong>社区活跃</strong>：MySQL 社区活跃，支持和资源丰富。</li><li><strong>易用性</strong>：MySQL 的安装和配置较为简单，易于上手。</li></ul></li><li><p><strong>为什么阿里巴巴的 Java 手册不推荐使用存储过程？</strong></p><ul><li><strong>可移植性差</strong>：存储过程依赖于特定的数据库，难以跨数据库移植。</li><li><strong>调试困难</strong>：存储过程的调试和维护较为复杂。</li><li><strong>影响可读性</strong>：业务逻辑分散在数据库和应用层，影响代码的可读性和可维护性。</li></ul></li></ul><h3 id="mysql数据类型" tabindex="-1"><a class="header-anchor" href="#mysql数据类型"><span>MySQL数据类型</span></a></h3><ul><li><p><strong>MySQL 中 int(11) 的 11 表示什么？</strong></p><ul><li><strong>显示宽度</strong>：11 表示显示宽度，不影响存储范围。主要用于 <code>ZEROFILL</code> 属性。</li></ul></li><li><p><strong>MySQL 中 varchar 和 char 有什么区别？</strong></p><ul><li><strong>存储方式</strong>：<code>CHAR</code> 固定长度，<code>VARCHAR</code> 可变长度。</li><li><strong>存储空间</strong>：<code>CHAR</code> 预留固定空间，<code>VARCHAR</code> 只占用实际字符数加1字节（长度）。</li><li><strong>性能</strong>：<code>CHAR</code> 插入和更新速度较快，<code>VARCHAR</code> 存储空间利用率更高。</li></ul></li><li><p><strong>MySQL 中 TEXT 类型最大可以存储多长的文本？</strong></p><ul><li><strong>TEXT</strong>：65,535 字节（约 64 KB）</li><li><strong>MEDIUMTEXT</strong>：16,777,215 字节（约 16 MB）</li><li><strong>LONGTEXT</strong>：4,294,967,295 字节（约 4 GB）</li></ul></li><li><p><strong>在 MySQL 中存储金额数据，应该使用什么数据类型？</strong></p><ul><li><strong>DECIMAL</strong>：用于存储精确的数值，避免浮点数精度丢失问题。</li></ul></li><li><p><strong>不推荐在 MySQL 中直接存储图片、音频、视频等大容量内容的原因是什么？</strong></p><ul><li><strong>性能问题</strong>：大文件存储和读取会影响数据库性能。</li><li><strong>备份和恢复</strong>：大文件备份和恢复耗时较长，影响维护效率。</li><li><strong>存储成本</strong>：数据库存储大文件会占用大量磁盘空间。</li></ul></li><li><p><strong>MySQL 中 VARCHAR(100) 和 VARCHAR(10) 的区别是什么？</strong></p><ul><li><strong>存储空间</strong>：<code>VARCHAR(100)</code> 最多存储 100 个字符，<code>VARCHAR(10)</code> 最多存储 10 个字符。</li><li><strong>显示宽度</strong>：不影响实际存储，仅用于显示宽度。</li></ul></li><li><p><strong>MySQL 中 DATETIME 和 TIMESTAMP 类型的区别是什么？</strong></p><ul><li><strong>存储范围</strong>：<code>DATETIME</code> 范围从 &#39;1000-01-01 00:00:00&#39; 到 &#39;9999-12-31 23:59:59&#39;，<code>TIMESTAMP</code> 范围从 &#39;1970-01-01 00:00:01&#39; UTC 到 &#39;2038-01-19 03:14:07&#39; UTC。</li><li><strong>存储空间</strong>：<code>DATETIME</code> 占用 8 字节，<code>TIMESTAMP</code> 占用 4 字节。</li><li><strong>时区</strong>：<code>TIMESTAMP</code> 自动转换为当前时区，<code>DATETIME</code> 不自动转换。</li></ul></li></ul><h3 id="三大范式与表设计" tabindex="-1"><a class="header-anchor" href="#三大范式与表设计"><span>三大范式与表设计</span></a></h3><ul><li><p><strong>MySQL 在设计表（建表）时需要注意什么？</strong></p><ul><li><strong>范式化</strong>：遵循范式化原则，减少数据冗余。</li><li><strong>索引设计</strong>：合理设计索引，提高查询性能。</li><li><strong>数据类型</strong>：选择合适的数据类型，节省存储空间。</li><li><strong>字段命名</strong>：使用有意义的字段名，提高代码可读性。</li><li><strong>约束</strong>：使用主键、外键等约束，确保数据完整性。</li></ul></li><li><p><strong>数据库的三大范式是什么？</strong></p><ul><li><strong>第一范式（1NF）</strong>：确保每个列都是原子的，不可再分。</li><li><strong>第二范式（2NF）</strong>：在满足 1NF 的基础上，消除非主属性对主键的部分依赖。</li><li><strong>第三范式（3NF）</strong>：在满足 2NF 的基础上，消除非主属性对主键的传递依赖。</li></ul></li><li><p><strong>什么是数据库的逻辑外键？数据库的物理外键和逻辑外键各有什么优缺点？</strong></p><ul><li><strong>物理外键</strong>：在数据库中定义的外键约束，确保数据完整性。 <ul><li><strong>优点</strong>：强制数据完整性，防止孤儿记录。</li><li><strong>缺点</strong>：影响插入和更新性能。</li></ul></li><li><strong>逻辑外键</strong>：在应用程序中实现的外键关系，不依赖于数据库约束。 <ul><li><strong>优点</strong>：灵活性高，不影响数据库性能。</li><li><strong>缺点</strong>：需要手动维护，容易出错。</li></ul></li></ul></li></ul><h2 id="mysql并发控制" tabindex="-1"><a class="header-anchor" href="#mysql并发控制"><span>MySQL并发控制</span></a></h2><h3 id="并发问题" tabindex="-1"><a class="header-anchor" href="#并发问题"><span>并发问题</span></a></h3><ul><li><strong>数据库的脏读、不可重复读和幻读分别是什么？</strong><ul><li><strong>脏读</strong>：读取了未提交的事务数据。</li><li><strong>不可重复读</strong>：在同一事务中多次读取同一数据，结果不一致。</li><li><strong>幻读</strong>：在同一事务中多次执行同一查询，结果集发生变化。</li></ul></li></ul><h3 id="事务与隔离级别" tabindex="-1"><a class="header-anchor" href="#事务与隔离级别"><span>事务与隔离级别</span></a></h3><ul><li><p><strong>MySQL 中的事务隔离级别有哪些？</strong></p><ul><li><strong>READ UNCOMMITTED</strong>：最低隔离级别，允许脏读。</li><li><strong>READ COMMITTED</strong>：允许不可重复读，但不允许脏读。</li><li><strong>REPEATABLE READ</strong>：默认隔离级别，允许幻读，但不允许脏读和不可重复读。</li><li><strong>SERIALIZABLE</strong>：最高隔离级别，完全隔离事务，防止所有并发问题。</li></ul></li><li><p><strong>MySQL 默认的事务隔离级别是什么？为什么选择这个级别？</strong></p><ul><li><strong>默认级别</strong>：<code>REPEATABLE READ</code></li><li><strong>原因</strong>：提供了较高的并发性能，同时防止了脏读和不可重复读。</li></ul></li><li><p><strong>你们生产环境的 MySQL 中使用了什么事务隔离级别？为什么？</strong></p><ul><li><strong>生产环境</strong>：通常使用 <code>REPEATABLE READ</code></li><li><strong>原因</strong>：平衡了并发性能和数据一致性，满足大多数应用场景的需求。</li></ul></li><li><p><strong>MySQL 是如何实现事务的？</strong></p><ul><li><strong>日志机制</strong>：通过重做日志（Redo Log）和回滚日志（Undo Log）确保事务的持久性和回滚功能。</li><li><strong>两阶段提交</strong>：确保事务的原子性和一致性。</li></ul></li><li><p><strong>MySQL 中长事务可能会导致哪些问题？</strong></p><ul><li><strong>锁定资源</strong>：长时间持有锁，影响其他事务的执行。</li><li><strong>日志堆积</strong>：重做日志和回滚日志堆积，影响性能。</li><li><strong>死锁</strong>：增加死锁的风险。</li></ul></li><li><p><strong>MySQL 事务的二阶段提交是什么？</strong></p><ul><li><strong>准备阶段</strong>：事务协调者通知所有参与者准备提交事务。</li><li><strong>提交阶段</strong>：事务协调者通知所有参与者提交事务，或回滚事务。</li></ul></li></ul><h3 id="mvcc实现原理" tabindex="-1"><a class="header-anchor" href="#mvcc实现原理"><span>MVCC实现原理</span></a></h3><ul><li><p><strong>MySQL 中的 MVCC 是什么？</strong></p><ul><li><strong>多版本并发控制</strong>：通过保存数据的多个版本，允许多个事务并发读取，同时保持数据一致性。</li></ul></li><li><p><strong>如果 MySQL 中没有 MVCC，会有什么影响？</strong></p><ul><li><strong>并发性能下降</strong>：事务需要等待其他事务完成，影响并发性能。</li><li><strong>数据一致性问题</strong>：容易出现脏读、不可重复读和幻读等问题。</li></ul></li></ul><h3 id="mysql日志" tabindex="-1"><a class="header-anchor" href="#mysql日志"><span>MySQL日志</span></a></h3><ul><li><strong>什么是 Write-Ahead Logging (WAL) 技术？它的优点是什么？MySQL 中是否用到了 WAL？</strong><ul><li><strong>WAL</strong>：在数据写入磁盘前，先将日志写入磁盘，确保数据的一致性和持久性。</li><li><strong>优点</strong>：提高了数据的安全性和恢复能力。</li><li><strong>MySQL</strong>：InnoDB 存储引擎使用了 WAL 技术。</li></ul></li></ul><h3 id="mysql中的锁" tabindex="-1"><a class="header-anchor" href="#mysql中的锁"><span>MySQL中的锁</span></a></h3><ul><li><p><strong>MySQL 中有哪些锁类型？</strong></p><ul><li><strong>共享锁（S 锁）</strong>：允许多个事务同时读取数据。</li><li><strong>排他锁（X 锁）</strong>：独占锁，不允许其他事务读取或写入数据。</li><li><strong>意向锁</strong>：用于表示事务对数据的意图，如意向共享锁（IS 锁）、意向排他锁（IX 锁）。</li></ul></li><li><p><strong>MySQL 的乐观锁和悲观锁是什么？</strong></p><ul><li><strong>乐观锁</strong>：假设冲突不经常发生，不加锁，通过版本号或时间戳检查冲突。</li><li><strong>悲观锁</strong>：假设冲突经常发生，加锁保护数据。</li></ul></li><li><p><strong>MySQL 中如果发生死锁应该如何解决？</strong></p><ul><li><strong>超时设置</strong>：设置事务超时时间，自动回滚超时事务。</li><li><strong>死锁检测</strong>：启用死锁检测，自动回滚其中一个事务。</li><li><strong>优化查询</strong>：减少事务的持有锁时间，避免复杂的嵌套事务。</li></ul></li></ul><h2 id="索引及性能优化" tabindex="-1"><a class="header-anchor" href="#索引及性能优化"><span>索引及性能优化</span></a></h2><h3 id="存储引擎" tabindex="-1"><a class="header-anchor" href="#存储引擎"><span>存储引擎</span></a></h3><ul><li><p><strong>MySQL 的存储引擎有哪些？它们之间有什么区别？</strong></p><ul><li><strong>InnoDB</strong>：支持事务，行级锁，适合高并发写操作。</li><li><strong>MyISAM</strong>：不支持事务，表级锁，适合读多写少的场景。</li><li><strong>Memory</strong>：数据存储在内存中，速度快但不持久。</li><li><strong>Archive</strong>：压缩存储，适合归档数据。</li><li><strong>CSV</strong>：数据存储在 CSV 文件中，适合数据交换。</li><li><strong>Blackhole</strong>：数据写入后丢弃，用于日志记录。</li><li><strong>Federated</strong>：访问远程 MySQL 服务器上的表。</li><li><strong>NDB Cluster</strong>：分布式存储，高可用性和负载均衡。</li></ul></li><li><p>MySQL InnoDB 引擎中的聚簇索引和非聚簇索引有什么区别？</p><p>聚簇索引：数据行按索引顺序存储，叶子节点存储完整数据行，适用于主键查询和范围查询。</p><p>非聚簇索引：数据行按聚簇索引顺序存储，叶子节点存储索引列值和聚簇索引键，适用于非主键列查询。</p></li></ul><h3 id="索引及其使用" tabindex="-1"><a class="header-anchor" href="#索引及其使用"><span>索引及其使用</span></a></h3><div class="hint-container info"><p class="hint-container-title">MySQL索引及其使用</p><h4 id="mysql-的索引类型有哪些" tabindex="-1"><a class="header-anchor" href="#mysql-的索引类型有哪些"><span>MySQL 的索引类型有哪些？</span></a></h4><ul><li>从数据结构角度来看，MySQL 索引可以分为以下几类：<br><strong>B+树索引，哈希索引，倒排索引(Full-Text)，R-树索引(多维空间树)</strong></li><li>从常见的基于 InnoDB B+树索引角度来看，可以分为：<br><strong>聚簇索引(Clustered Index)，非聚簇索引(Non-clustered Index)</strong></li><li>从索引性质的角度来看，可以分为：<br><strong>普通索引(二级索引、辅助索引)，主键索引，唯一索引，联合索引，全文索引，空间索引</strong></li></ul><h4 id="在-mysql-中建索引时需要注意哪些事项" tabindex="-1"><a class="header-anchor" href="#在-mysql-中建索引时需要注意哪些事项"><span>在 MySQL 中建索引时需要注意哪些事项？</span></a></h4><ol><li><strong>避免过度索引</strong>：索引会占用磁盘空间，并增加插入、更新和删除操作的开销。</li><li><strong>选择性高的列优先建索引</strong>： 重复值较多的列（如性别）通常不适合建索引。</li><li><strong>避免在长字段上建索引</strong>：长字段（如 <code>TEXT</code>、<code>LONGTEXT</code>）会占用大量内存，可能降低整体性能。</li><li><strong>考虑表的修改频率</strong>： 如果表的修改频率远大于查询频率，应慎重考虑是否建索引，因为索引会减慢修改操作。</li><li><strong>频繁作为查询条件的列建索引</strong>：经常出现在 <code>WHERE</code> 子句中的列应建索引，以提高查询效率。 多个条件经常一起查询时，可以考虑联合索引，减少索引数量。</li><li><strong>对 <code>ORDER BY</code>、<code>GROUP BY</code>、<code>DISTINCT</code> 的列建索引</strong>： 这些操作通常需要对结果进行排序、分组或去重，索引可以显著提高这些操作的性能。</li></ol><h4 id="mysql-中使用索引一定有效吗-如何排查索引效果" tabindex="-1"><a class="header-anchor" href="#mysql-中使用索引一定有效吗-如何排查索引效果"><span>MySQL 中使用索引一定有效吗？如何排查索引效果？</span></a></h4><ul><li><strong>不一定有效</strong>：索引可能因选择性低、数据分布不均等原因失效。</li><li><strong>排查方法</strong>：使用 <code>EXPLAIN</code> 语句查看查询计划，检查索引是否被使用。</li></ul><h4 id="mysql-中的索引数量是否越多越好-为什么" tabindex="-1"><a class="header-anchor" href="#mysql-中的索引数量是否越多越好-为什么"><span>MySQL 中的索引数量是否越多越好？为什么？</span></a></h4><ul><li><strong>不是越多越好</strong>：索引会占用磁盘空间，增加插入、更新和删除操作的开销。</li><li><strong>合理创建</strong>：根据实际查询需求，选择合适的列创建索引。</li></ul></div><h3 id="回表及索引覆盖" tabindex="-1"><a class="header-anchor" href="#回表及索引覆盖"><span>回表及索引覆盖</span></a></h3><p>最左前缀原则: 指的是在组合索引中，查询条件必须从索引的最左边的列开始匹配，才能有效利用索引。</p><p>回表（Table Lookup） 是指在使用非聚集索引（Secondary Index）进行查询时，数据库引擎需要先通过非聚集索引找到数据行的指针，然后再访问实际的数据行的过程(即需要再返回到主键索引树查询一次)。如何避免回表：</p><ul><li><p>尽量避免写 select * ，仅查询需要的字段，如果这些字段均包含在索引字段内且符合最左前缀原则，就可以不用回表了</p></li><li><p>合理设计索引，可以考虑使用联合索引</p></li><li><p><strong>MySQL 的索引下推是什么？</strong><br> 索引下推（Index Condition Pushdown，ICP）是指通过在索引扫描过程中提前过滤掉不符合条件的记录，减少了回表操作的次数，从而提高了查询性能。</p></li></ul><h3 id="b-树" tabindex="-1"><a class="header-anchor" href="#b-树"><span>B+树</span></a></h3><ul><li><p><strong>MySQL 的 B+ 树中查询数据的全过程是什么？</strong></p><ul><li><strong>根节点</strong>：从根节点开始，根据查询条件找到相应的子节点。</li><li><strong>中间节点</strong>：继续向下查找，直到找到叶子节点。</li><li><strong>叶子节点</strong>：在叶子节点中找到具体的记录，返回结果。</li></ul></li><li><p><strong>为什么 MySQL 选择使用 B+ 树作为索引结构？</strong></p><ul><li><strong>高效查询</strong>：B+ 树支持快速的范围查询和排序。</li><li><strong>内存友好</strong>：B+ 树的中间节点只存储键值，叶子节点存储完整数据，适合内存缓存。</li></ul></li><li><p><strong>MySQL 三层 B+ 树能存多少数据？</strong></p><ul><li><strong>估算</strong>：假设每个节点存储 1000 个键值，三层 B+ 树可以存储约 1000 * 1000 * 1000 = 10^9 条记录。</li></ul></li></ul><h3 id="查询和执行过程" tabindex="-1"><a class="header-anchor" href="#查询和执行过程"><span>查询和执行过程</span></a></h3><ul><li><p><strong>详细描述一条 SQL 语句在 MySQL 中的执行过程。</strong></p><ul><li><strong>连接管理</strong>：验证客户端的连接信息，建立连接。</li><li><strong>解析</strong>：将 SQL 语句转换为内部的解析树（Parse Tree），检查语法错误。</li><li><strong>预处理</strong>：解析表名、列名等标识符，检查权限。</li><li><strong>优化</strong>：查询优化器根据解析树生成最优的查询执行计划。</li><li><strong>执行</strong>：执行器根据优化器生成的执行计划，实际执行 SQL 语句。</li></ul></li><li><p><strong>为什么在 MySQL 中不推荐使用多表 JOIN？</strong></p><ul><li><strong>性能问题</strong>：多表 JOIN 会导致大量的表扫描和数据比较，影响查询性能。</li><li><strong>维护难度</strong>：复杂的 JOIN 语句难以维护和调试。</li></ul></li></ul><h3 id="执行计划与sql调优" tabindex="-1"><a class="header-anchor" href="#执行计划与sql调优"><span>执行计划与SQL调优</span></a></h3><p>查询执行顺序：from - where -group by -having - select - order by-limit</p><ul><li><p><strong>MySQL 数据库的性能优化方法有哪些？</strong></p><ul><li><strong>索引优化</strong>：合理创建和使用索引，减少 I/O 操作。</li><li><strong>查询优化</strong>：使用 <code>EXPLAIN</code> 语句分析查询计划，优化查询逻辑。</li><li><strong>缓存优化</strong>：合理使用查询缓存和缓存策略。</li><li><strong>硬件优化</strong>：增加内存、使用更快的磁盘等。</li><li><strong>分区优化</strong>：对大表进行分区，提高查询性能。</li></ul></li><li><p><strong>MySQL 中如何进行 SQL 调优？</strong></p><ul><li><strong>使用 <code>EXPLAIN</code></strong>：分析查询计划，找出瓶颈。</li><li><strong>优化索引</strong>：创建合适的索引，减少回表操作。</li><li><strong>简化查询</strong>：拆分复杂的查询，减少表扫描。</li><li><strong>批量操作</strong>：使用批量插入和更新，减少 I/O 操作。</li></ul></li></ul><div class="hint-container info"><p class="hint-container-title">SQL调优</p><h4 id="定位问题" tabindex="-1"><a class="header-anchor" href="#定位问题"><span>定位问题</span></a></h4><p>线上日志，其他数据库工具如MYSQL中的慢查询日志</p><h4 id="查看执行计划" tabindex="-1"><a class="header-anchor" href="#查看执行计划"><span>查看执行计划</span></a></h4><h4 id="sql本身问题-加索引" tabindex="-1"><a class="header-anchor" href="#sql本身问题-加索引"><span>SQL本身问题 / 加索引</span></a></h4><ul><li><p>避免回表</p></li><li><p>避免在 where 子句中使用or来连接条件</p></li><li><p>应考虑在 where 及 order by 涉及的列上建立索引，联表查询的条件</p></li><li><p>使用联合索引</p></li></ul><h4 id="复杂sql优化" tabindex="-1"><a class="header-anchor" href="#复杂sql优化"><span>复杂SQL优化</span></a></h4><p>SQL本身联表过多，且使用了函数和非索引字段排序</p><p>这种通常需要在业务层分解业务，重新实现功能， 对于查询条件相对固定的，且实时性要求不高的，可以考虑做定时任务，缓存结果</p><h4 id="分库分表" tabindex="-1"><a class="header-anchor" href="#分库分表"><span>分库分表</span></a></h4><ol><li>冷热分离</li><li>正式的分库分表</li></ol></div><ul><li><p><strong>如何在 MySQL 中监控和优化慢 SQL？</strong></p><ul><li><strong>慢查询日志</strong>：启用慢查询日志，记录执行时间较长的查询。</li><li><strong>性能分析工具</strong>：使用 <code>EXPLAIN</code> 和 <code>SHOW PROFILES</code> 等工具分析查询性能。</li><li><strong>优化查询</strong>：根据分析结果优化查询逻辑和索引。</li></ul></li><li><p><strong>如何使用 MySQL 的 EXPLAIN 语句进行查询分析？</strong></p><ul><li><strong>语法</strong>：<code>EXPLAIN SELECT ...</code></li><li><strong>输出</strong>：查看 <code>EXPLAIN</code> 输出，重点关注 <code>type</code>、<code>possible_keys</code>、<code>key</code>、<code>rows</code> 等列，分析查询计划。</li><li><strong>优化</strong>：根据分析结果优化查询逻辑和索引。</li></ul></li><li><p><strong>MySQL 的查询优化器如何选择执行计划？</strong></p><ul><li><strong>统计信息</strong>：查询优化器根据表的统计信息（如行数、列分布等）选择最优的执行计划。</li><li><strong>代价模型</strong>：评估不同执行计划的代价，选择代价最小的计划。</li></ul></li></ul><h3 id="mysql-buffer" tabindex="-1"><a class="header-anchor" href="#mysql-buffer"><span>MySQL Buffer</span></a></h3><ul><li>从 MySQL 获取数据，是从磁盘读取的吗？</li></ul><p>从 MySQL 获取数据时，首先会检查缓冲池中是否有所需的数据页。如果有，直接从内存中读取；如果没有，则从磁盘读取数据页到缓冲池中，然后再从缓冲池中读取数据。(从 MySQL 8.0 开始，查询缓存已经被移除)</p><div class="hint-container info"><p class="hint-container-title">Buffer</p><h4 id="mysql-的-change-buffer-是什么-它有什么作用" tabindex="-1"><a class="header-anchor" href="#mysql-的-change-buffer-是什么-它有什么作用"><span>MySQL 的 Change Buffer 是什么？它有什么作用？</span></a></h4><p>Change Buffer 是一种优化机制，通过延迟和批量处理（二级）索引变更，减少了磁盘 I/O 次数</p><h4 id="mysql-的-doublewrite-buffer-是什么-它有什么作用" tabindex="-1"><a class="header-anchor" href="#mysql-的-doublewrite-buffer-是什么-它有什么作用"><span>MySQL 的 Doublewrite Buffer 是什么？它有什么作用？</span></a></h4><p>Doublewrite Buffer 是一种重要的数据保护机制，通过确保数据页的完整性和一致性，防止部分写失败导致的数据损坏</p><h4 id="mysql-的-log-buffer-是什么-它有什么作用" tabindex="-1"><a class="header-anchor" href="#mysql-的-log-buffer-是什么-它有什么作用"><span>MySQL 的 Log Buffer 是什么？它有什么作用？</span></a></h4><p>Log Buffer 是 InnoDB 存储引擎中用于暂存重做日志的一个内存缓冲区，通过减少磁盘 I/O 次数和提高写入性能，确保了数据的一致性和完整性，同时也提高了系统的整体性能和并发能力</p></div><h2 id="mysql高可用和扩展" tabindex="-1"><a class="header-anchor" href="#mysql高可用和扩展"><span>MySQL高可用和扩展</span></a></h2><ul><li><p><strong>如何在 MySQL 中避免单点故障？</strong></p><ul><li><strong>主从复制</strong>：使用主从复制，确保数据冗余。</li><li><strong>负载均衡</strong>：使用负载均衡器分担读写压力。</li><li><strong>故障切换</strong>：配置自动故障切换机制，确保高可用性。</li></ul></li><li><p><strong>如何实现数据库的不停服迁移？</strong></p><ul><li><strong>在线迁移</strong>：使用在线迁移工具（如 pt-online-schema-change）进行无停机迁移。</li><li><strong>双写方案</strong>：在新旧数据库中同时写入数据，逐步切换流量。</li></ul></li></ul><h3 id="主从复制" tabindex="-1"><a class="header-anchor" href="#主从复制"><span>主从复制</span></a></h3><ul><li><p><strong>如何在 MySQL 中实现读写分离？</strong></p><ul><li><strong>代理工具</strong>：使用代理工具（如 ProxySQL、MaxScale）自动路由读写请求。</li><li><strong>应用层</strong>：在应用程序中手动分发读写请求。</li></ul></li><li><p><strong>什么是 MySQL 的主从同步机制？它是如何实现的？</strong></p><ul><li><strong>主从同步</strong>：主库将事务日志（Binlog）发送给从库，从库应用日志进行数据同步。</li><li><strong>实现</strong>：主库开启 Binlog，从库配置主库地址，从库通过 IO 线程读取 Binlog，通过 SQL 线程应用日志。</li></ul></li><li><p><strong>如何处理 MySQL 的主从同步延迟？</strong></p><ul><li><strong>优化网络</strong>：改善网络环境，减少传输延迟。</li><li><strong>优化 Binlog</strong>：减少 Binlog 的大小，提高传输效率。</li><li><strong>并行复制</strong>：启用并行复制，提高同步速度。</li><li><strong>监控和报警</strong>：定期监控同步延迟，设置报警机制。</li></ul></li></ul><h3 id="分库分表-1" tabindex="-1"><a class="header-anchor" href="#分库分表-1"><span>分库分表</span></a></h3><ul><li><p><strong>什么是分库分表？分库分表有哪些类型（或策略）？</strong></p><ul><li><strong>分库分表</strong>：将数据分散到多个数据库和表中，提高性能和可扩展性。</li><li><strong>类型</strong>：水平分表（按行分表）、垂直分表（按列分表）、混合分表。</li></ul></li><li><p><strong>如果组长要求你主导项目中的分库分表，大致的实施流程是？</strong></p><ul><li><strong>需求分析</strong>：确定分库分表的目标和需求。</li><li><strong>方案设计</strong>：选择合适的分库分表策略，设计分库分表方案。</li><li><strong>工具选型</strong>：选择合适的分库分表工具（如 ShardingSphere）。</li><li><strong>数据迁移</strong>：进行数据迁移，确保数据一致性和完整性。</li><li><strong>测试验证</strong>：进行全面的测试，验证分库分表的效果。</li><li><strong>上线监控</strong>：上线后持续监控性能和稳定性。</li></ul></li><li><p><strong>对数据库进行分库分表可能会引发哪些问题？</strong></p><ul><li><strong>数据一致性</strong>：跨库事务处理复杂，容易出现数据不一致。</li><li><strong>查询复杂度</strong>：跨库查询和联表查询变得复杂。</li><li><strong>维护难度</strong>：数据库结构复杂，维护和管理难度增加。</li><li><strong>性能瓶颈</strong>：不当的分库分表策略可能导致新的性能瓶颈。</li></ul></li></ul>',48)]))}const c=n(i,[["render",t],["__file","mysql.html.vue"]]),d=JSON.parse(`{"path":"/java/interview/frame/mysql.html","title":"MySQL","lang":"en-US","frontmatter":{"order":1,"title":"MySQL","description":"MySQL数据库基础 基础及常见问题 MySQL 中 EXISTS 和 IN 的区别是什么？ EXISTS：通常用于检查子查询是否返回至少一行数据，返回布尔值（存在或不存在）。性能较好，特别是在子查询结果集较大的情况下。 IN：用于检查某个值是否存在于子查询的结果集中，返回布尔值。适用于结果集较小的情况。 MySQL 中 count(*)、count(...","head":[["meta",{"property":"og:url","content":"https://x.app/java/interview/frame/mysql.html"}],["meta",{"property":"og:site_name","content":"doc"}],["meta",{"property":"og:title","content":"MySQL"}],["meta",{"property":"og:description","content":"MySQL数据库基础 基础及常见问题 MySQL 中 EXISTS 和 IN 的区别是什么？ EXISTS：通常用于检查子查询是否返回至少一行数据，返回布尔值（存在或不存在）。性能较好，特别是在子查询结果集较大的情况下。 IN：用于检查某个值是否存在于子查询的结果集中，返回布尔值。适用于结果集较小的情况。 MySQL 中 count(*)、count(..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-04-01T10:22:54.000Z"}],["meta",{"property":"article:author","content":"ventixy"}],["meta",{"property":"article:modified_time","content":"2025-04-01T10:22:54.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-01T10:22:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ventixy\\",\\"url\\":\\"https://www.ventix.top\\"}]}"]]},"headers":[{"level":2,"title":"MySQL数据库基础","slug":"mysql数据库基础","link":"#mysql数据库基础","children":[{"level":3,"title":"基础及常见问题","slug":"基础及常见问题","link":"#基础及常见问题","children":[]},{"level":3,"title":"其他问题","slug":"其他问题","link":"#其他问题","children":[]},{"level":3,"title":"MySQL数据类型","slug":"mysql数据类型","link":"#mysql数据类型","children":[]},{"level":3,"title":"三大范式与表设计","slug":"三大范式与表设计","link":"#三大范式与表设计","children":[]}]},{"level":2,"title":"MySQL并发控制","slug":"mysql并发控制","link":"#mysql并发控制","children":[{"level":3,"title":"并发问题","slug":"并发问题","link":"#并发问题","children":[]},{"level":3,"title":"事务与隔离级别","slug":"事务与隔离级别","link":"#事务与隔离级别","children":[]},{"level":3,"title":"MVCC实现原理","slug":"mvcc实现原理","link":"#mvcc实现原理","children":[]},{"level":3,"title":"MySQL日志","slug":"mysql日志","link":"#mysql日志","children":[]},{"level":3,"title":"MySQL中的锁","slug":"mysql中的锁","link":"#mysql中的锁","children":[]}]},{"level":2,"title":"索引及性能优化","slug":"索引及性能优化","link":"#索引及性能优化","children":[{"level":3,"title":"存储引擎","slug":"存储引擎","link":"#存储引擎","children":[]},{"level":3,"title":"索引及其使用","slug":"索引及其使用","link":"#索引及其使用","children":[]},{"level":3,"title":"回表及索引覆盖","slug":"回表及索引覆盖","link":"#回表及索引覆盖","children":[]},{"level":3,"title":"B+树","slug":"b-树","link":"#b-树","children":[]},{"level":3,"title":"查询和执行过程","slug":"查询和执行过程","link":"#查询和执行过程","children":[]},{"level":3,"title":"执行计划与SQL调优","slug":"执行计划与sql调优","link":"#执行计划与sql调优","children":[]},{"level":3,"title":"MySQL Buffer","slug":"mysql-buffer","link":"#mysql-buffer","children":[]}]},{"level":2,"title":"MySQL高可用和扩展","slug":"mysql高可用和扩展","link":"#mysql高可用和扩展","children":[{"level":3,"title":"主从复制","slug":"主从复制","link":"#主从复制","children":[]},{"level":3,"title":"分库分表","slug":"分库分表-1","link":"#分库分表-1","children":[]}]}],"git":{"createdTime":1736522381000,"updatedTime":1743502974000,"contributors":[{"name":"drizzle","email":"msdrizzle@outlook.com","commits":1}]},"readingTime":{"minutes":18.56,"words":5568},"filePathRelative":"java/interview/frame/mysql.md","localizedDate":"January 10, 2025","excerpt":"<h2>MySQL数据库基础</h2>\\n<h3>基础及常见问题</h3>\\n<ul>\\n<li>\\n<p><strong>MySQL 中 EXISTS 和 IN 的区别是什么？</strong></p>\\n<ul>\\n<li><strong>EXISTS</strong>：通常用于检查子查询是否返回至少一行数据，返回布尔值（存在或不存在）。性能较好，特别是在子查询结果集较大的情况下。</li>\\n<li><strong>IN</strong>：用于检查某个值是否存在于子查询的结果集中，返回布尔值。适用于结果集较小的情况。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？</strong></p>\\n<ul>\\n<li><strong>count(*)</strong>：统计所有行数，包括 NULL 值。</li>\\n<li><strong>count(1)</strong>：等同于 <code>count(*)</code>，常用于提高可读性。</li>\\n<li><strong>count(字段名)</strong>：统计指定字段不为 NULL 的行数。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>MySQL 中 INNER JOIN、LEFT JOIN 和 RIGHT JOIN 的区别是什么？</strong></p>\\n<ul>\\n<li><strong>INNER JOIN</strong>：返回两个表中匹配的行。</li>\\n<li><strong>LEFT JOIN</strong>：返回左表中的所有行，以及右表中匹配的行。如果右表中没有匹配的行，结果为 NULL。</li>\\n<li><strong>RIGHT JOIN</strong>：返回右表中的所有行，以及左表中匹配的行。如果左表中没有匹配的行，结果为 NULL。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>MySQL 中 DELETE、DROP 和 TRUNCATE 的区别是什么？</strong></p>\\n<ul>\\n<li><strong>DELETE</strong>：删除表中的特定行，可以使用 WHERE 子句指定条件，操作日志记录。</li>\\n<li><strong>TRUNCATE</strong>：删除表中的所有行，不记录日志，速度快，但不能回滚。</li>\\n<li><strong>DROP</strong>：删除整个表，包括表结构，操作不可逆。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>什么是数据库的逻辑删除？数据库的物理删除和逻辑删除有什么区别？</strong></p>\\n<ul>\\n<li><strong>逻辑删除</strong>：通过设置标志位（如 <code>is_deleted</code>）来标记记录已删除，实际数据仍保留在数据库中。</li>\\n<li><strong>物理删除</strong>：彻底删除记录，释放存储空间。</li>\\n<li><strong>区别</strong>：逻辑删除可以恢复数据，物理删除不可恢复，且释放存储空间。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>在 MySQL 中，你使用过哪些函数？</strong></p>\\n<ul>\\n<li><strong>字符串函数</strong>：<code>LOWER()</code>、<code>UPPER()</code>、<code>CONCAT()</code>、<code>SUBSTRING()</code></li>\\n<li><strong>数值函数</strong>：<code>ABS()</code>、<code>CEIL()</code>、<code>FLOOR()</code>、<code>ROUND()</code></li>\\n<li><strong>日期函数</strong>：<code>NOW()</code>、<code>CURDATE()</code>、<code>CURTIME()</code>、<code>DATE_ADD()</code>、<code>DATE_SUB()</code></li>\\n<li><strong>聚合函数</strong>：<code>COUNT()</code>、<code>SUM()</code>、<code>AVG()</code>、<code>MAX()</code>、<code>MIN()</code></li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>MySQL 中的数据排序是怎么实现的？</strong></p>\\n<ul>\\n<li><strong>命中索引</strong>：如果排序字段命中索引，MySQL 直接使用索引排序。</li>\\n<li><strong>文件排序（Filesort）</strong>：如果未命中索引，MySQL 使用文件排序算法进行排序。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>MySQL 中 AUTO_INCREMENT 列达到最大值时会发生什么？</strong></p>\\n<ul>\\n<li><strong>错误</strong>：MySQL 会抛出错误 <code>Error 1062: Duplicate entry '...' for key 'PRIMARY'</code>。</li>\\n<li><strong>解决方案</strong>：手动重置 AUTO_INCREMENT 值，或删除表后重建。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>MySQL 中 <code>LIMIT 100000000, 10</code> 和 <code>LIMIT 10</code> 的执行速度是否相同？</strong></p>\\n<ul>\\n<li><strong>不同</strong>：<code>LIMIT 100000000, 10</code> 需要先跳过前 100000000 行，性能较差；<code>LIMIT 10</code> 只需要获取前 10 行，性能较好。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>MySQL 中如何解决深度分页的问题？</strong></p>\\n<ul>\\n<li><strong>使用覆盖索引</strong>：减少回表操作。</li>\\n<li><strong>使用键值对存储</strong>：将分页数据预先存储在键值对中。</li>\\n<li><strong>使用临时表</strong>：将分页数据存储在临时表中，减少查询次数。</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}`);export{c as comp,d as data};
